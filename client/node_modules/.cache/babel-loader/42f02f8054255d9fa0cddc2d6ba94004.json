{"ast":null,"code":"var inputAlphabet = \"\";\nvar pushdownAlphabet = \"\";\nvar states = \"\";\nvar transitions = \"\";\nvar stack = \"\";\nvar initialState = \"\";\nvar final = \"\";\nvar model = \"\";\nvar initialStack = \"\"; // leftmost char will be top of stack\n\nvar all = \"\";\n\nfunction parseStates(input) {\n  //console.log(\"Parsing States\");\n  let input_array = input.split(',');\n  let states_array = [];\n\n  for (let i in input_array) {\n    let str_state = input_array[i];\n    states_array[i] = new State(str_state.replace(\" \", \"\"));\n  }\n\n  return states_array;\n}\n\nfunction parseInputAlphabet(input) {\n  //console.log(\"Paring Input Alphabet\");\n  let inputAlphabet_array = input.split(',');\n\n  for (let i in inputAlphabet_array) {\n    let alpha = inputAlphabet_array[i];\n    inputAlphabet_array[i] = alpha.replace(\" \", \"\");\n  }\n\n  return inputAlphabet_array;\n}\n\nfunction parsePushdownAlphabet(input) {\n  //console.log(\"Parsing Pushdown Alphabet\");\n  let pushdownAlphabet_array = input.split(',');\n\n  for (let i in pushdownAlphabet_array) {\n    let alpha = pushdownAlphabet_array[i];\n    pushdownAlphabet_array[i] = alpha.replace(\" \", \"\");\n  }\n\n  return pushdownAlphabet_array;\n} // (q0, a, S) -> (q1, S); (q1, e, S) -> (q2, SS); ...\n\n\nfunction parseTransitions(input) {\n  //console.log(\"Parsing Transitions\");\n  let transitions = input.split(';');\n  let transArray = [];\n\n  for (let i in transitions) {\n    let pair = transitions[i].split(\" -> \");\n    let src = pair[0].split(','); //(q0, a, Z)\n\n    let dest = pair[1].split(','); // (q1, A)\n\n    for (let j in src) {\n      src[j] = src[j].replace(\" \", \"\").replace(\"(\", \"\").replace(\")\", \"\");\n    }\n\n    dest[0] = dest[0].replace(\" \", \"\").replace(\"(\", \"\");\n    dest[1] = dest[1].replace(\" \", \"\").replace(\")\", \"\");\n    let state1 = new State(src[0]);\n    let state2 = new State(dest[0]);\n    transArray[i] = new Transition(state1, state2, src[1], src[2], dest[1]);\n  }\n\n  return transArray;\n}\n\nexport class State {\n  // same as DFA\n  constructor(name) {\n    this.name = name;\n    this.accepting = false;\n    this.connected = false;\n    this.conn = [];\n  }\n\n}\nexport class Transition {\n  // (source, input, stack0) -> (dest, stack1)\n  constructor(source, dest, input, stack0, stack1) {\n    this.input = input;\n    this.source = source;\n    this.dest = dest;\n    this.stack0 = stack0;\n    this.stack1 = stack1;\n  }\n\n  static getDest() {\n    return this.dest;\n  }\n\n}\nexport class PDAModel {\n  constructor(all_states, initialState, inputAlphabet, pushdownAlphabet, transitions, initialStack, accepting) {\n    this.all = parseStates(all_states);\n    this.pushdownAlphabet = parsePushdownAlphabet(pushdownAlphabet);\n    this.transitions = parseTransitions(transitions);\n    this.inputAlphabet = parseInputAlphabet(inputAlphabet);\n    this.initialStack = initialStack;\n    this.accepting = parseStates(accepting);\n    this.inputSyms = null;\n    this.pdSyms = null; //this.ts = new Map();\n\n    this.srcToInput = new Map();\n    this.srcToStack = new Map();\n    this.currentState = null;\n    this.currentStack = null;\n    this.epsTransitions = [];\n    if (!this.checkInputAlphabet()) console.log(\"Invalid Input Alphabet\"); //console.log(this.pushdownAlphabet.size);\n\n    if (!this.checkPushdownAlphabet()) console.log(\"Invalid Pushdown alphabet\"); //console.log(\"here\");\n\n    if (!this.checkInitialStack()) console.log(\"Invalid Initial Stack\");\n    if (!this.checkStates()) console.log(\"Invalid states\"); //if (!this.checkInitialState()) console.log(\"Invalid initial state\");\n    //else {\n    //   this.initialState = this.getInitialState(initialState);\n    //}\n\n    if (!this.getInitialState(initialState)) console.log(\"Invalid Initial State\");\n    if (!this.checkAccepting()) console.log(\"Invalid Accepting array\");\n    if (!this.checkTransitions()) console.log(\"Invalid transitions\"); //if (!this.checkDeterministic()) console.log(\"Non-deterministic\");\n    //else console.log(\"Deterministic\");\n\n    this.makeConnected(this.initialState);\n\n    for (let i in this.all) {\n      let s = this.all[i];\n\n      if (!s.connected) {\n        console.log(\"State \" + s.name + \" is not reachable.\");\n      }\n    }\n  }\n\n  getInitialState(name) {\n    if (name == null || name == \"\") return false;\n\n    for (let i in this.all) {\n      let st = this.all[i];\n\n      if (st.name === name) {\n        this.initialState = st;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  checkInputString(input) {\n    this.currentState = this.initialState;\n    this.currentStack = this.initialStack;\n    let path = []; // path is gonna have each transition object\n\n    for (let i = 0; i < input.length; i++) {\n      let sym = input.substring(i, i + 1);\n      let worked = false;\n      let epsTran = null;\n\n      for (let j in this.transitions) {\n        let t = this.transitions[j];\n\n        if (t.source === this.currentState && t.input === sym && t.stack0 === this.currentStack.substring(0, 1)) {\n          path.push(t);\n          this.currentState = t.dest;\n          if (t.stack1 != \"eps\") this.currentStack = t.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n          worked = true;\n          break;\n        } else if (t.input == \"eps\" && t.source == this.currentState && t.stack0 == this.currentStack.substring(0, 1)) {\n          epsTran = t;\n        }\n      }\n\n      if (!worked && epsTran != null) {\n        path.push(epsTran);\n        this.currentState = epsTran.dest;\n        if (epsTran.stack1 != \"eps\") this.currentStack = epsTran.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n        i--;\n      } else if (!worked) {\n        console.log(\"No transition suitable\");\n        return false;\n      }\n    }\n\n    while (this.currentStack != \"\") {\n      let worked = false;\n\n      for (let j in this.epsTransitions) {\n        let et = this.epsTransitions[j];\n\n        if (et.source === this.currentState && this.currentStack.substring(0, 1) === et.stack0) {\n          path.push(et);\n          this.currentState = et.dest;\n          if (et.stack1 != \"eps\") this.currentStack = et.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n          worked = true;\n        }\n      }\n\n      if (!worked) {\n        console.log(\"non-empty stack\");\n        return false;\n      }\n    }\n\n    let endState = false;\n\n    for (let i in this.accepting) {\n      let s = this.accepting[i];\n\n      if (s.name === this.currentState.name) {\n        endState = true;\n        break;\n      }\n    }\n\n    if (endState) return path;else {\n      console.log(\"Not in end state\");\n      return false;\n    }\n  }\n\n  checkInputAlphabet() {\n    if (this.inputAlphabet.size === 0) return false;\n    let symbols = new Set();\n\n    for (let s in this.inputAlphabet) {\n      let i = this.inputAlphabet[s];\n      if (symbols.has(i)) return false;\n      symbols.add(i);\n    }\n\n    this.inputSyms = symbols;\n    return true;\n  }\n\n  checkPushdownAlphabet() {\n    if (this.pushdownAlphabet.size == 0) return false;\n    let symbols = new Set();\n\n    for (let s in this.pushdownAlphabet) {\n      let i = this.pushdownAlphabet[s];\n      if (symbols.has(i) || this.inputSyms.has(i)) return false;\n      symbols.add(i);\n    }\n\n    this.pdSyms = symbols; //console.log(this.pdSyms.size());\n\n    return true;\n  }\n\n  checkStates() {\n    if (this.all.size == 0) return false;\n    let states = new Map();\n\n    for (let i in this.all) {\n      let s = this.all[i];\n      if (states != null && (states.has(s.name) || this.pdSyms.has(s.name) || this.inputSyms.has(s.name))) return false;\n      states.set(s.name, s);\n    }\n\n    this.states = states;\n    return true;\n  }\n\n  checkInitialState() {\n    if (this.states.has(this.initialState.name)) {\n      //this.initialState = this.states.has(initialState.name);\n      this.initialState.connected = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  checkInitialStack() {\n    for (let i in initialStack) {\n      let sym = initialStack.substring(i, i + 1);\n\n      if (!this.pdSyms.has(sym)) {\n        //this.initialStack = this.pdSyms.get(initialStack)\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  checkAccepting() {\n    for (let i in all) {\n      let s = all[i];\n      if (!this.states.has(s)) return false;\n      s.accepting = true;\n      this.accepting.push(s);\n    }\n\n    return true;\n  }\n\n  checkTransitions() {\n    if (this.transitions.size === 0) return false;\n\n    for (let i in this.transitions) {\n      let t = this.transitions[i];\n      if (t.input != \"eps\" && !this.inputSyms.has(t.input)) return false; // must accept empty\n\n      if (t.stack0 != \"eps\" && !this.pdSyms.has(t.stack0)) return false;\n      let st = false;\n      let end = false;\n\n      for (let x in this.all) {\n        let cc = this.all[x];\n        if (st && end) break;\n\n        if (cc.name === t.source.name) {\n          st = true;\n          t.source = cc;\n        }\n\n        if (cc.name === t.dest.name) {\n          end = true;\n          t.dest = cc;\n        }\n      }\n\n      if (!(st && end)) return false; // check new stack:\n\n      if (t.stack1 != \"eps\") {\n        for (let x in t.stack1) {\n          let c = t.stack1.substring(x, x + 1);\n          if (!this.pdSyms.has(c)) return false;\n        }\n      }\n\n      if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input) && this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n        return false;\n      } // doesn't have the stack symbol yet\n      else if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input)) {\n        let symList = this.srcToInput.get(t.source);\n        symList.push(t.input);\n        this.srcToInput.set(t.source, symList);\n      } // doesnt have the input symbol yet\n      else if (this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n        let symList = this.srcToStack.get(t.source);\n        symList.push(t.stack0);\n        this.srcToStack.set(t.source, symList);\n      } // has the source, but neither the symbol nor the input\n      else if (this.srcToStack.has(t.source) && this.srcToInput.has(t.source)) {\n        let inList = this.srcToInput.get(t.source);\n        inList.push(t.input);\n        this.srcToInput.set(t.source, inList);\n        let stackList = this.srcToStack.get(t.source);\n        stackList.push(t.stack0);\n        this.srcToStack.set(t.source, inList);\n      } // state has yet to be recorded as a source\n      else {\n        let inList = new Array(t.input);\n        let stList = new Array(t.stack0);\n        this.srcToInput.set(t.source, inList);\n        this.srcToStack.set(t.source, stList);\n      }\n\n      if (!t.source.conn.includes(t.dest) && t.source.name != t.dest.name) {\n        t.source.conn.push(t.dest);\n        t.source.connected = true;\n        if (t.source.name === this.initialState.name) this.initialState = t.source;\n      } // Adding to list of Transitions with eps as input\n\n\n      if (t.input === \"eps\") {\n        this.epsTransitions.push(t);\n      }\n    }\n\n    return true;\n  }\n\n  makeConnected(start) {\n    for (let i in start.conn) {\n      let s = start.conn[i];\n\n      if (!s.connected) {\n        s.connected = true;\n        this.makeConnected(s);\n      }\n    }\n  }\n\n}\nlet states1 = \"q0, q1\";\nlet startState1 = \"q0\";\nlet inputAlphabet1 = \"a, b\";\nlet pushdownAlphabet1 = \"A, Z\";\nlet transitions1 = \"(q0, a, Z) -> (q0, AZ); (q0, a, A) -> (q0, AA); (q0, b, A) -> (q1, eps); (q1, b, A) -> (q1, eps); (q1, eps, Z) -> (q1, eps)\";\nlet startStack1 = \"Z\";\nlet accepting1 = \"q1\";\nlet astring1 = \"aaabbb\"; // Z\n\nlet astring2 = \"aaaabbbb\"; // Z\n\nlet astring3 = \"abbb\"; // AZAZ\n\nlet astring4 = \"bbbbb\"; // AAAAA\n\nlet astring5 = \"bbb\"; // AZAZAZZZZ\n\nlet rstring1 = \"aabbba\"; // A, Z, AAZ\n\nlet rstring2 = \"\"; // anything: A, Z, AA, AAZZ\n\nlet rstring3 = \"ab\"; // Z\n\nlet rstring4 = \"a\"; // Z, A\n\nlet rstring5 = \"aaabbb\"; // AA, A\n\nlet Z_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"Z\", accepting1);\nlet A_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"A\", accepting1);\nlet AA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AA\", accepting1);\nlet AAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAZ\", accepting1);\nlet AZAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZ\", accepting1);\nlet AAAAA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAAAA\", accepting1);\nlet AZAZAZZZZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZAZZZZ\", accepting1);\n/* TESTS: change return statement of checkInputString from return path; to return true; to test again\n// Accept\nif (Z_PDA.checkInputString(\"aaabbb\")) console.log(\"test1: correct output - passed\");\nelse console.log(\"test1: failed\");\n\nif (Z_PDA.checkInputString(astring2)) console.log(\"test2: correct output - passed\")\nelse console.log(\"test2: failed\");\n\n//Wrong test here\nif (AZAZ_PDA.checkInputString(\"abbb\")) console.log(\"test3: correct output - passed\");\nelse console.log(\"test3: failed\"); \n\nif (AAAAA_PDA.checkInputString(\"bbbbb\")) console.log(\"test4: correct output - passed\");\nelse console.log(\"test4: failed\");\n\nif (AZAZAZZZZ_PDA.checkInputString(\"bbb\")) console.log(\"test5: correct output - passed\");\nelse console.log(\"test5: failed\"); \n\nif (Z_PDA.checkInputString(\"ab\")) console.log(\"test13: correct output - passed\");\nelse console.log(\"test13: failed\");\n\nif (A_PDA.checkInputString(\"aaabbbb\")) console.log(\"test16: correct output - passed\");\nelse console.log(\"test16: failed\");\n\n// Reject\nif (!A_PDA.checkInputString(\"aabbba\")) console.log(\"test6: correct output - rejected\");\nelse console.log(\"test6: failed\");\n\nif (!Z_PDA.checkInputString(\"aabbba\")) console.log(\"test7: correct output - rejected\");\nelse console.log(\"test7: failed\");\n\nif (!AAZ_PDA.checkInputString(\"aabbba\")) console.log(\"test8: correct output - rejected\");\nelse console.log(\"test8: failed\");\n\nif (!A_PDA.checkInputString(\"\")) console.log(\"test9: correct output - rejected\");\nelse console.log(\"test9: failed\");\n\nif (!Z_PDA.checkInputString(\"\")) console.log(\"test10: correct output - rejected\");\nelse console.log(\"test10: failed\");\n\nif (!AAZ_PDA.checkInputString(\"\")) console.log(\"test11: correct output - rejected\");\nelse console.log(\"test11: failed\");\n\nif (!AAAAA_PDA.checkInputString(\"\")) console.log(\"test12: correct output - rejected\");\nelse console.log(\"test12: failed\");\n\nif (!Z_PDA.checkInputString(\"a\")) console.log(\"test14: correct output - rejected\");\nelse console.log(\"test14: failed\");\n\nif (!A_PDA.checkInputString(\"a\")) console.log(\"test15: correct output - rejected\");\nelse console.log(\"test15: failed\");\n\nif (!AA_PDA.checkInputString(\"aaabbbb\")) console.log(\"test17: correct output - rejected\");\nelse console.log(\"test17: failed\");\n*/","map":{"version":3,"names":["inputAlphabet","pushdownAlphabet","states","transitions","stack","initialState","final","model","initialStack","all","parseStates","input","input_array","split","states_array","i","str_state","State","replace","parseInputAlphabet","inputAlphabet_array","alpha","parsePushdownAlphabet","pushdownAlphabet_array","parseTransitions","transArray","pair","src","dest","j","state1","state2","Transition","constructor","name","accepting","connected","conn","source","stack0","stack1","getDest","PDAModel","all_states","inputSyms","pdSyms","srcToInput","Map","srcToStack","currentState","currentStack","epsTransitions","checkInputAlphabet","console","log","checkPushdownAlphabet","checkInitialStack","checkStates","getInitialState","checkAccepting","checkTransitions","makeConnected","s","st","checkInputString","path","length","sym","substring","worked","epsTran","t","push","concat","et","endState","size","symbols","Set","has","add","set","checkInitialState","end","x","cc","c","get","includes","symList","inList","stackList","Array","stList","start","states1","startState1","inputAlphabet1","pushdownAlphabet1","transitions1","startStack1","accepting1","astring1","astring2","astring3","astring4","astring5","rstring1","rstring2","rstring3","rstring4","rstring5","Z_PDA","A_PDA","AA_PDA","AAZ_PDA","AZAZ_PDA","AAAAA_PDA","AZAZAZZZZ_PDA"],"sources":["/Users/simonlow/Documents/ModelsOfCompSimulator-2/client/src/components/input/PDAModel.js"],"sourcesContent":["var inputAlphabet = \"\"\nvar pushdownAlphabet = \"\"\nvar states = \"\"\nvar transitions = \"\"\nvar stack = \"\"\nvar initialState = \"\"\nvar final = \"\"\nvar model = \"\"\nvar initialStack = \"\" // leftmost char will be top of stack\nvar all = \"\"\n\n\nfunction parseStates(input) {\n    //console.log(\"Parsing States\");\n    let input_array = input.split(',');\n    let states_array = [];\n    for (let i in input_array) {\n        let str_state = input_array[i];\n        states_array[i] = new State(str_state.replace(\" \", \"\"));\n    }\n    return states_array;\n}\n\nfunction parseInputAlphabet(input) {\n    //console.log(\"Paring Input Alphabet\");\n    let inputAlphabet_array = input.split(',');\n    for (let i in inputAlphabet_array) {\n        let alpha = inputAlphabet_array[i];\n        inputAlphabet_array[i] = alpha.replace(\" \", \"\");\n    }\n    return inputAlphabet_array;\n}\n\nfunction parsePushdownAlphabet(input) {\n    //console.log(\"Parsing Pushdown Alphabet\");\n    let pushdownAlphabet_array = input.split(',');\n    for (let i in pushdownAlphabet_array) {\n        let alpha = pushdownAlphabet_array[i];\n        pushdownAlphabet_array[i] = alpha.replace(\" \", \"\");\n    }\n    return pushdownAlphabet_array;\n}\n\n// (q0, a, S) -> (q1, S); (q1, e, S) -> (q2, SS); ...\nfunction parseTransitions(input) {\n    //console.log(\"Parsing Transitions\");\n    let transitions = input.split(';');\n    let transArray = [];\n    for (let i in transitions) {\n        let pair = transitions[i].split(\" -> \");\n        let src = pair[0].split(','); //(q0, a, Z)\n        let dest = pair[1].split(','); // (q1, A)\n\n        for (let j in src) {\n            src[j] = src[j].replace(\" \", \"\").replace(\"(\", \"\").replace(\")\", \"\");\n        }\n        dest[0] = dest[0].replace(\" \" , \"\").replace(\"(\", \"\");\n        dest[1] = dest[1].replace(\" \", \"\").replace(\")\", \"\");\n\n        let state1 = new State(src[0]);\n        let state2 = new State(dest[0]);\n\n        transArray[i] = new Transition(state1, state2, src[1], src[2], dest[1]);\n    }\n    return transArray; \n}\n\nexport class State { // same as DFA\n    constructor(name) {\n        this.name = name;\n        this.accepting = false;\n        this.connected = false;\n        this.conn = [];\n    }\n}\n\nexport class Transition { // (source, input, stack0) -> (dest, stack1)\n    constructor(source, dest, input, stack0, stack1) {\n        this.input = input;\n        this.source = source;\n        this.dest = dest;\n        this.stack0 = stack0;\n        this.stack1 = stack1;\n    }\n\n    static getDest() {\n        return this.dest;\n    }\n}\n\nexport class PDAModel {\n    constructor(all_states, initialState, inputAlphabet, pushdownAlphabet, transitions, initialStack, accepting) {\n        this.all = parseStates(all_states);\n        this.pushdownAlphabet = parsePushdownAlphabet(pushdownAlphabet);\n        this.transitions = parseTransitions(transitions);\n        this.inputAlphabet = parseInputAlphabet(inputAlphabet);\n        this.initialStack = initialStack;\n        this.accepting = parseStates(accepting);\n        this.inputSyms = null;\n        this.pdSyms = null;\n        //this.ts = new Map();\n        this.srcToInput = new Map();\n        this.srcToStack = new Map();\n        this.currentState = null;\n        this.currentStack = null;\n        this.epsTransitions = [];\n\n        \n        \n        if (!this.checkInputAlphabet()) console.log(\"Invalid Input Alphabet\");\n        //console.log(this.pushdownAlphabet.size);\n        if (!this.checkPushdownAlphabet()) console.log(\"Invalid Pushdown alphabet\");\n        //console.log(\"here\");\n        if (!this.checkInitialStack()) console.log(\"Invalid Initial Stack\");\n        if (!this.checkStates()) console.log(\"Invalid states\");\n        //if (!this.checkInitialState()) console.log(\"Invalid initial state\");\n        //else {\n         //   this.initialState = this.getInitialState(initialState);\n        //}\n        if (!this.getInitialState(initialState)) console.log(\"Invalid Initial State\");\n        if (!this.checkAccepting()) console.log(\"Invalid Accepting array\");\n        if (!this.checkTransitions()) console.log(\"Invalid transitions\");\n        //if (!this.checkDeterministic()) console.log(\"Non-deterministic\");\n        //else console.log(\"Deterministic\");\n\n        this.makeConnected(this.initialState);\n        for (let i in this.all) {\n            let s = this.all[i];\n            if (!s.connected) {\n                console.log(\"State \" + s.name + \" is not reachable.\");\n            }\n        }\n    }\n\n    getInitialState(name) {\n        if (name == null || name == \"\") return false; \n        for (let i in this.all) {\n            let st = this.all[i];\n            if (st.name === name) {\n                this.initialState = st;\n                return true;\n            }\n        }\n        return false; \n    }\n\n    checkInputString(input) {\n        this.currentState = this.initialState;\n        this.currentStack = this.initialStack;\n        let path = []; // path is gonna have each transition object\n        for(let i = 0; i < input.length; i++) {\n            let sym = input.substring(i, i+1);\n            let worked = false;\n            let epsTran = null;\n            for(let j in this.transitions) {\n                let t = this.transitions[j];\n                if ((t.source === this.currentState) && (t.input === sym) && (t.stack0 === this.currentStack.substring(0, 1))) {\n                    path.push(t);\n                    this.currentState = t.dest;\n                    if (t.stack1 != \"eps\") this.currentStack = t.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));\n                    else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n                    worked = true;\n                    break;\n                }\n                else if ((t.input == \"eps\") && (t.source == this.currentState) && (t.stack0 == this.currentStack.substring(0,1))) {\n                    epsTran = t;\n                }\n            }   \n            if (!worked && epsTran != null) {\n                path.push(epsTran);\n                this.currentState = epsTran.dest;\n                if (epsTran.stack1 != \"eps\") this.currentStack = epsTran.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));\n                else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n                i--;\n            }    \n            else if (!worked){\n                console.log(\"No transition suitable\");\n                return false;  \n            }   \n        }\n        while (this.currentStack != \"\") {\n            let worked = false;\n            for (let j in this.epsTransitions) {\n                let et = this.epsTransitions[j];\n                if (et.source === this.currentState && this.currentStack.substring(0, 1) === et.stack0) {\n                    path.push(et);\n                    this.currentState = et.dest;\n                    if (et.stack1 != \"eps\") this.currentStack = et.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));\n                    else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n                    worked = true; \n                }\n            }\n            if (!worked) {\n                console.log(\"non-empty stack\");\n                return false; \n        \n            }\n        }\n\n        let endState = false; \n        for (let i in this.accepting) {\n            let s = this.accepting[i];\n            if (s.name === this.currentState.name) {\n                endState = true; \n                break;\n            }\n        }\n\n        if (endState) return path;\n        else {\n            console.log(\"Not in end state\");\n            return false; \n        }\n    }\n\n    checkInputAlphabet() {\n        if (this.inputAlphabet.size === 0) return false;\n        let symbols = new Set();\n        for (let s in this.inputAlphabet) {\n            let i = this.inputAlphabet[s];\n            if (symbols.has(i)) return false;\n            symbols.add(i);\n        }\n\n        this.inputSyms = symbols;\n        return true;\n    }\n    \n    checkPushdownAlphabet() {\n        if (this.pushdownAlphabet.size == 0) return false;\n\n        let symbols = new Set();\n        for (let s in this.pushdownAlphabet) {\n            let i = this.pushdownAlphabet[s];\n            if (symbols.has(i) || this.inputSyms.has(i)) return false;\n            symbols.add(i);\n        }\n\n        this.pdSyms = symbols;\n        //console.log(this.pdSyms.size());\n        return true;\n    }\n\n    checkStates() {\n        if (this.all.size == 0) return false;\n\n        let states = new Map();\n        for (let i in this.all) {\n            let s = this.all[i];\n            if (states != null && (states.has(s.name) || this.pdSyms.has(s.name) || this.inputSyms.has(s.name))) return false;\n            states.set(s.name, s);\n        }\n\n        this.states = states;\n        return true;\n    }\n\n    checkInitialState() {\n        if (this.states.has(this.initialState.name)) {\n            //this.initialState = this.states.has(initialState.name);\n            this.initialState.connected = true;\n            return true;\n        }\n        return false;\n    }\n\n    checkInitialStack() {\n        for(let i in initialStack) {\n            let sym = initialStack.substring(i, i+1);\n            if (!this.pdSyms.has(sym)) {\n                //this.initialStack = this.pdSyms.get(initialStack)\n                return false\n            }\n        }\n        \n        return true;\n    }\n\n    checkAccepting() {\n        for (let i in all) {\n            let s = all[i];\n            if (!this.states.has(s)) return false;\n            s.accepting = true;\n            this.accepting.push(s);\n        }\n        return true; \n    \n    }\n\n    checkTransitions() {\n        if (this.transitions.size === 0) return false;\n\n        for (let i in this.transitions) {\n            let t = this.transitions[i];\n            if (t.input != \"eps\" && !this.inputSyms.has(t.input)) return false; // must accept empty\n            if (t.stack0 != \"eps\" && !this.pdSyms.has(t.stack0)) return false;\n            let st = false;\n            let end = false;\n            for (let x in this.all) {\n                let cc = this.all[x];\n                if (st && end) break;\n                if (cc.name === t.source.name) {\n                    st = true;\n                    t.source = cc;\n                }\n                if (cc.name === t.dest.name) {\n                    end = true;\n                    t.dest = cc;\n                }\n                \n            }\n            if (!(st && end)) return false;\n    \n            // check new stack:\n            if (t.stack1 != \"eps\") {\n                for (let x in t.stack1) {\n                    let c = t.stack1.substring(x, x+1);\n                    if (!this.pdSyms.has(c)) return false; \n                }\n            }\n\n            if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input) \n                && this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n                    return false;\n            }\n            // doesn't have the stack symbol yet\n            else if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input)){\n                let symList = this.srcToInput.get(t.source);\n                symList.push(t.input);\n                this.srcToInput.set(t.source, symList);\n            }\n            // doesnt have the input symbol yet\n            else if (this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n                let symList = this.srcToStack.get(t.source);\n                symList.push(t.stack0);\n                this.srcToStack.set(t.source, symList);\n            }\n            // has the source, but neither the symbol nor the input\n            else if (this.srcToStack.has(t.source) && this.srcToInput.has(t.source)){\n                let inList = this.srcToInput.get(t.source);\n                inList.push(t.input);\n                this.srcToInput.set(t.source, inList);\n                let stackList = this.srcToStack.get(t.source);\n                stackList.push(t.stack0);\n                this.srcToStack.set(t.source, inList);\n            }\n            // state has yet to be recorded as a source\n            else {\n                let inList = new Array(t.input);\n                let stList = new Array(t.stack0);\n                this.srcToInput.set(t.source, inList);\n                this.srcToStack.set(t.source, stList);\n            }\n\n            if (!t.source.conn.includes(t.dest) && t.source.name != t.dest.name) {\n                t.source.conn.push(t.dest);\n                t.source.connected = true; \n                if (t.source.name === this.initialState.name) this.initialState = t.source;\n            }\n\n            // Adding to list of Transitions with eps as input\n            if (t.input === \"eps\") {\n                this.epsTransitions.push(t);\n            }\n        }\n        return true;\n    }\n    \n    makeConnected(start) {\n        for (let i in start.conn) {\n            let s = start.conn[i]; \n            if (!s.connected) {\n                s.connected = true;\n                this.makeConnected(s);\n            }\n        }\n    }\n}\n\nlet states1 = \"q0, q1\";\nlet startState1 = \"q0\";\nlet inputAlphabet1 = \"a, b\";\nlet pushdownAlphabet1 = \"A, Z\";\nlet transitions1 = \"(q0, a, Z) -> (q0, AZ); (q0, a, A) -> (q0, AA); (q0, b, A) -> (q1, eps); (q1, b, A) -> (q1, eps); (q1, eps, Z) -> (q1, eps)\"\nlet startStack1 = \"Z\";\nlet accepting1 = \"q1\";\n\nlet astring1 = \"aaabbb\"; // Z\nlet astring2 = \"aaaabbbb\"; // Z\nlet astring3 = \"abbb\"; // AZAZ\nlet astring4 = \"bbbbb\"; // AAAAA\nlet astring5 = \"bbb\"; // AZAZAZZZZ\n\nlet rstring1 = \"aabbba\"; // A, Z, AAZ\nlet rstring2 = \"\"; // anything: A, Z, AA, AAZZ\nlet rstring3 = \"ab\" // Z\nlet rstring4 = \"a\" // Z, A\nlet rstring5 = \"aaabbb\"; // AA, A\n\nlet Z_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"Z\", accepting1);\nlet A_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"A\", accepting1);\nlet AA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AA\", accepting1);\nlet AAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAZ\", accepting1);\nlet AZAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZ\", accepting1);\nlet AAAAA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAAAA\", accepting1);\nlet AZAZAZZZZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZAZZZZ\", accepting1);\n\n\n/* TESTS: change return statement of checkInputString from return path; to return true; to test again\n// Accept\nif (Z_PDA.checkInputString(\"aaabbb\")) console.log(\"test1: correct output - passed\");\nelse console.log(\"test1: failed\");\n\nif (Z_PDA.checkInputString(astring2)) console.log(\"test2: correct output - passed\")\nelse console.log(\"test2: failed\");\n\n//Wrong test here\nif (AZAZ_PDA.checkInputString(\"abbb\")) console.log(\"test3: correct output - passed\");\nelse console.log(\"test3: failed\"); \n\nif (AAAAA_PDA.checkInputString(\"bbbbb\")) console.log(\"test4: correct output - passed\");\nelse console.log(\"test4: failed\");\n\nif (AZAZAZZZZ_PDA.checkInputString(\"bbb\")) console.log(\"test5: correct output - passed\");\nelse console.log(\"test5: failed\"); \n\nif (Z_PDA.checkInputString(\"ab\")) console.log(\"test13: correct output - passed\");\nelse console.log(\"test13: failed\");\n\nif (A_PDA.checkInputString(\"aaabbbb\")) console.log(\"test16: correct output - passed\");\nelse console.log(\"test16: failed\");\n\n// Reject\nif (!A_PDA.checkInputString(\"aabbba\")) console.log(\"test6: correct output - rejected\");\nelse console.log(\"test6: failed\");\n\nif (!Z_PDA.checkInputString(\"aabbba\")) console.log(\"test7: correct output - rejected\");\nelse console.log(\"test7: failed\");\n\nif (!AAZ_PDA.checkInputString(\"aabbba\")) console.log(\"test8: correct output - rejected\");\nelse console.log(\"test8: failed\");\n\nif (!A_PDA.checkInputString(\"\")) console.log(\"test9: correct output - rejected\");\nelse console.log(\"test9: failed\");\n\nif (!Z_PDA.checkInputString(\"\")) console.log(\"test10: correct output - rejected\");\nelse console.log(\"test10: failed\");\n\nif (!AAZ_PDA.checkInputString(\"\")) console.log(\"test11: correct output - rejected\");\nelse console.log(\"test11: failed\");\n\nif (!AAAAA_PDA.checkInputString(\"\")) console.log(\"test12: correct output - rejected\");\nelse console.log(\"test12: failed\");\n\nif (!Z_PDA.checkInputString(\"a\")) console.log(\"test14: correct output - rejected\");\nelse console.log(\"test14: failed\");\n\nif (!A_PDA.checkInputString(\"a\")) console.log(\"test15: correct output - rejected\");\nelse console.log(\"test15: failed\");\n\nif (!AA_PDA.checkInputString(\"aaabbbb\")) console.log(\"test17: correct output - rejected\");\nelse console.log(\"test17: failed\");\n*/\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}