{"ast":null,"code":"import { Transition, parseAlphabet, parseTransition } from \"./DFAModel\";\nexport class Pair {\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n  }\n\n  equalTo(other) {\n    if (this.left == other.left && this.right == other.right) return true;\n    return false;\n  }\n\n}\nexport class NFAState {\n  constructor(name) {\n    this.name = name;\n    this.accepting = false;\n    this.connected = false;\n    this.conn = [];\n    this.transitions = [];\n  }\n\n  addTrans(symbol, dest) {\n    this.transitions.push(new Pair(symbol, dest));\n  }\n\n  getAllTrans() {\n    return this.transitions;\n  }\n\n  getEpsilonTrans() {\n    let ret_list = [];\n\n    for (let i in this.transitions) {\n      let ts = this.transitions[i];\n\n      if (ts.left === \"eps\") {\n        ret_list.push(ts);\n      }\n    }\n\n    return ret_list;\n  }\n\n  getSymbolTrans(sym) {\n    let ret_list = [];\n\n    for (let i in this.transitions) {\n      let ts = this.transitions[i];\n\n      if (ts.left === sym) {\n        ret_list.push(ts);\n      }\n    }\n\n    return ret_list;\n  }\n\n}\nexport class NFAModel {\n  constructor(initial, accepting, all_states, alphabet, transitions) {\n    console.log(\"NFA Model:\");\n    this.all = parseNFAStates(all_states);\n    this.initial = null;\n    this.accepting = [];\n    this.alphabet = parseAlphabet(alphabet);\n    this.transitions = parseTransition(transitions);\n    this.current = new Set();\n    this.syms = null;\n    this.states = null;\n    this.error = null;\n    this.setPath = []; //this.ts = new Map();\n\n    console.log(\"initial: \", initial);\n    console.log(\"accepting: \", accepting);\n    console.log(\"states: \", all_states);\n    console.log(\"alphabet: \", alphabet);\n    console.log(\"transitions: \", transitions); // check components and alert if error\n\n    if (!this.checkAlphabet()) window.alert(this.error);\n    if (!this.checkStates()) window.alert(this.error);\n    if (!this.checkInitial(initial)) window.alert(this.error);\n    if (!this.checkAccepting(accepting)) window.alert(this.error);\n    if (!this.checkTransitions()) window.alert(this.error); // make Connected for all and check\n\n    this.makeConnected(this.initial);\n\n    for (let i in this.all) {\n      let s = this.all[i];\n\n      if (!s.connected) {\n        console.log(\"State \" + s.name + \" is not reachable.\");\n      }\n    }\n  }\n\n  acceptString() {\n    console.log(this.setPath);\n    let ret_path = [new Pair(\"\", this.initial)];\n\n    for (let a of this.current) {\n      if (a.accepting) {\n        // create acceptance visualization and add it to end of path\n        let accept_state = new NFAState(\"üôÇ\");\n        let acceptance = new Pair(\"‚úîÔ∏è\", accept_state);\n        ret_path.push(acceptance);\n        console.log(ret_path);\n        return ret_path;\n      }\n    } // if not accepting, create fail visualization and add it to end of path\n\n\n    let fail_state = new NFAState(\"üôÅ\");\n    let failure = new Pair(\"‚ùå\", fail_state);\n    ret_path.push(failure);\n    return ret_path;\n  }\n\n  checkInputString(input) {\n    // create Set to represent next states and initialize current Set to initial state\n    let next = new Set();\n    this.current = new Set().add(this.initial); // add all epsilon transitons from initial state\n\n    let eps_trans = this.initial.getEpsilonTrans();\n\n    if (eps_trans.length != 0) {\n      for (let trans of eps_trans) {\n        next.add(trans.right);\n      }\n\n      this.current.add(...next);\n    }\n\n    this.setPath.push(this.current); // loop through input\n\n    while (input.length > 0) {\n      let str = input.substring(0, 1);\n      input = input.substring(1);\n      let next = new Set();\n\n      for (let a of this.current) {\n        let eps_trans = a.getEpsilonTrans();\n\n        if (eps_trans.length != 0) {\n          for (let trans of eps_trans) {\n            next.add(trans.right);\n          }\n        }\n\n        let sym_trans = a.getSymbolTrans(str);\n\n        if (sym_trans.length != 0) {\n          for (let trans of sym_trans) {\n            next.add(trans.right);\n          }\n        }\n      }\n\n      for (let b of next) {\n        let eps_trans = b.getEpsilonTrans();\n\n        if (eps_trans != 0) {\n          for (let trans of eps_trans) {\n            next.add(trans.right);\n          }\n        }\n      }\n\n      this.setPath.push(this.current);\n      this.current = next;\n    }\n\n    return this.acceptString();\n  }\n  /*\n  // given a path, checks whether end state is accepting and adds success/fail marker if so\n  acceptString(current, path) {\n      // Check if the current state is an accepting state\n      let ret_path = [...path];\n      for (let i in this.accepting) {\n          let s = this.accepting[i];\n          if (s == current) {\n              // create acceptance visualization and add it to end of path\n              let accept_state = new NFAState(\"üôÇ\");\n              let acceptance = new Pair(\"‚úîÔ∏è\", accept_state);\n              ret_path.push(acceptance);\n              return ret_path;\n          }\n      }\n      // if not accepting, create fail visualization and add it to end of path\n      let fail_state = new NFAState(\"üôÅ\");\n      let failure = new Pair(\"‚ùå\", fail_state);\n      ret_path.push(failure);\n      return ret_path;\n  }\n  \n  // call checkPath\n  checkInputString(input) {\n      console.log(input);\n      // Pass initial state and input as current and create new path starting from initial\n      let init_path = [new Pair(\"\", this.initial)];\n      return this.checkPath(input + \"\\\\\", this.initial, init_path);\n  }\n   // recursively check path for acceptance\n  checkPath(input, current, path) {\n      console.log(\"CheckPath: \");\n      console.log(path);\n      // if string is down to the final \"\\\", return the path\n      if (input === \"\\\\\") {\n          // if accepting string, return the path immediately\n          console.log(path);\n          let acceptance = this.acceptString(current, path);\n          console.log(\"Path 2: \")\n          console.log(path);\n          if (acceptance[acceptance.length - 1].right.name == \"üôÇ\") {\n              return acceptance;\n          }\n           // if not accepting, check for any epsilon transitions\n          for (let trans of current.getTrans()) {\n              if (trans.left == \"eps\") {\n                  path.push(trans);\n                  return this.checkPath(input, trans.right, path);\n              }\n          }\n           return acceptance;\n      } \n      \n      // Take first char of string, check transitions for match, update to new state and repeat when found\n      let str = input.substring(0, 1);\n      // input string fails if a character is not in alphabet\n      if (!this.syms.has(str)) {\n          window.alert(\"Character \" + str + \" is not in alphabet\");\n          return null;\n      }\n      \n      // Check each transition in the list, if symbol matches or epsilon, recur on the next step down the path\n      for (let trans of current.getTrans()) {\n          console.log(\"Trans: \" + trans);\n          if (str == trans.left) {\n              path.push(trans);\n              return this.checkPath(input.substring(1), trans.right, path);\n          }\n          if (trans.left == \"eps\") {\n              path.push(trans);\n              return this.checkPath(input, trans.right, path);\n          }\n      }\n  } */\n  // Checks alphabet for repeated symbols or being empty\n\n\n  checkAlphabet() {\n    if (this.alphabet.size === 0) {\n      this.error = \"Empty alphabet\";\n      return false;\n    }\n\n    let symbols = new Set();\n    symbols.add(\"eps\");\n\n    for (let i in this.alphabet) {\n      let s = this.alphabet[i];\n\n      if (symbols.has(s)) {\n        this.error = \"Duplicate in alphabet: \" + s;\n        return false;\n      }\n\n      symbols.add(s);\n    }\n\n    this.syms = symbols;\n    return true;\n  } // Checks states for repeats or conflicts with alphabet\n\n\n  checkStates() {\n    if (this.all.size === 0) {\n      this.error = \"Empty States\";\n      return false;\n    }\n\n    let states = new Map();\n\n    for (let i in this.all) {\n      let s = this.all[i];\n\n      if (states.has(s.name) || this.syms.has(s.name)) {\n        this.error = \"Conflicting state name: \" + s.name;\n        return false;\n      }\n\n      states.set(s.name, s);\n    }\n\n    this.states = states;\n    return true;\n  } // Checks that initial state is a valid state and assigns it\n\n\n  checkInitial(initial) {\n    if (this.states.has(initial)) {\n      this.initial = this.states.get(initial);\n      this.initial.connected = true;\n      return true;\n    }\n\n    this.error = \"Invalid initial state\";\n    return false;\n  } // Checks that accepting states are present and valid\n\n\n  checkAccepting(accepting) {\n    let acc_array = parseAlphabet(accepting);\n\n    if (acc_array.size === 0) {\n      this.error = \"Empty accepting states\";\n      return false;\n    }\n\n    for (let i in acc_array) {\n      let acc_name = acc_array[i];\n\n      if (!this.states.has(acc_name)) {\n        this.error = \"Accepting state \" + acc_name + \" does not exist\";\n        return false;\n      }\n\n      this.states.get(acc_name).accepting = true;\n      this.accepting.push(this.states.get(acc_name));\n    }\n\n    return true;\n  } // Checks that transitions are valid symbols/states/states\n  // Sets up connections to check all states are connected\n\n\n  checkTransitions() {\n    if (this.transitions.size === 0) {\n      this.error = \"Empty transitions\";\n      return false;\n    }\n\n    for (let i in this.transitions) {\n      let t = this.transitions[i]; // confirm that the symbol and source/dest states exist \n\n      if (!this.syms.has(t.symbol)) {\n        this.error = \"Invalid symbol in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n        return false;\n      }\n\n      if (!this.states.has(t.source)) {\n        this.error = \"Invalid source in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n        return false;\n      }\n\n      if (!this.states.has(t.dest)) {\n        this.error = \"Invalid destination in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n        return false;\n      }\n\n      t.source = this.states.get(t.source);\n      t.dest = this.states.get(t.dest);\n      let src_state = t.source;\n\n      for (let j in src_state.getAllTrans()) {\n        let ts = src_state.getAllTrans()[j];\n\n        if (ts.left == t.symbol && ts.right == t.dest) {\n          // duplicate transition\n          this.error = \"Transition (\" + t.symbol + \", \" + t.source.name + \", \" + t.dest.name + \") already exists\";\n          return false;\n        }\n      }\n\n      src_state.addTrans(t.symbol, t.dest); // add for connection check\n\n      if (!t.source.conn.includes(t.dest)) {\n        t.source.conn.push(t.dest);\n      }\n    }\n\n    return true;\n  } // uses conn lists in states to set connected to bool value\n\n\n  makeConnected(start) {\n    for (let i in start.conn) {\n      let s = start.conn[i];\n\n      if (!s.connected) {\n        s.connected = true;\n        this.makeConnected(s);\n      }\n    }\n  }\n\n} // parse states string input into NFAState array\n\nexport function parseNFAStates(input) {\n  let input_array = input.split(',');\n  let states_array = [];\n\n  for (let i in input_array) {\n    let str_state = input_array[i];\n    states_array[i] = new NFAState(str_state.replace(\" \", \"\"));\n  }\n\n  return states_array;\n}","map":{"version":3,"names":["Transition","parseAlphabet","parseTransition","Pair","constructor","left","right","equalTo","other","NFAState","name","accepting","connected","conn","transitions","addTrans","symbol","dest","push","getAllTrans","getEpsilonTrans","ret_list","i","ts","getSymbolTrans","sym","NFAModel","initial","all_states","alphabet","console","log","all","parseNFAStates","current","Set","syms","states","error","setPath","checkAlphabet","window","alert","checkStates","checkInitial","checkAccepting","checkTransitions","makeConnected","s","acceptString","ret_path","a","accept_state","acceptance","fail_state","failure","checkInputString","input","next","add","eps_trans","length","trans","str","substring","sym_trans","b","size","symbols","has","Map","set","get","acc_array","acc_name","t","source","src_state","j","includes","start","input_array","split","states_array","str_state","replace"],"sources":["/Users/simonlow/Documents/ModelsOfCompSimulator-2/client/src/components/input/NFAModel.js"],"sourcesContent":["import { Transition, parseAlphabet, parseTransition } from \"./DFAModel\";\n\nexport class Pair {\n    constructor(left, right) {\n        this.left = left;\n        this.right = right;\n    }\n\n    equalTo(other) {\n        if ((this.left == other.left) && (this.right == other.right)) return true;\n        return false;\n    }\n}\n\nexport class NFAState {\n    constructor(name) {\n        this.name = name;\n        this.accepting = false;\n        this.connected = false;\n        this.conn = [];\n        this.transitions = [];\n    }\n\n    addTrans(symbol, dest) {\n        this.transitions.push(new Pair(symbol, dest));\n    }\n\n    getAllTrans() {\n        return this.transitions;\n    }\n\n    getEpsilonTrans() {\n        let ret_list = [];\n        for (let i in this.transitions) {\n            let ts = this.transitions[i];\n            if (ts.left === \"eps\") {\n                ret_list.push(ts);\n            }\n        }\n        return ret_list;\n    }\n\n    getSymbolTrans(sym) {\n        let ret_list = [];\n        for (let i in this.transitions) {\n            let ts = this.transitions[i];\n            if (ts.left === sym) {\n                ret_list.push(ts);\n            }\n        }\n        return ret_list;\n    }\n}\n\nexport class NFAModel {\n    constructor(initial, accepting, all_states, alphabet, transitions) {\n        console.log(\"NFA Model:\");\n        this.all = parseNFAStates(all_states);\n        this.initial = null;\n        this.accepting = [];\n        this.alphabet = parseAlphabet(alphabet);\n        this.transitions = parseTransition(transitions);\n        this.current = new Set();\n        this.syms = null;\n        this.states = null;\n        this.error = null;\n        this.setPath = [];\n        //this.ts = new Map();\n\n        console.log(\"initial: \", initial);\n        console.log(\"accepting: \", accepting);\n        console.log(\"states: \", all_states);\n        console.log(\"alphabet: \", alphabet);\n        console.log(\"transitions: \", transitions);\n\n        // check components and alert if error\n        if (!this.checkAlphabet()) window.alert(this.error);\n        if (!this.checkStates()) window.alert(this.error);\n        if (!this.checkInitial(initial)) window.alert(this.error);\n        if (!this.checkAccepting(accepting)) window.alert(this.error);\n        if (!this.checkTransitions()) window.alert(this.error);\n\n        // make Connected for all and check\n        this.makeConnected(this.initial);\n        for (let i in this.all) {\n            let s = this.all[i];\n            if (!s.connected) {\n                console.log(\"State \" + s.name + \" is not reachable.\");\n            }\n        }\n    }\n\n    acceptString() {\n        console.log(this.setPath);\n        let ret_path = [new Pair(\"\", this.initial)];\n        for (let a of this.current) {\n            if (a.accepting) {\n                // create acceptance visualization and add it to end of path\n                let accept_state = new NFAState(\"üôÇ\");\n                let acceptance = new Pair(\"‚úîÔ∏è\", accept_state);\n                ret_path.push(acceptance);\n                console.log(ret_path);\n                return ret_path;\n            }\n        }\n        // if not accepting, create fail visualization and add it to end of path\n        let fail_state = new NFAState(\"üôÅ\");\n        let failure = new Pair(\"‚ùå\", fail_state);\n        ret_path.push(failure);\n        return ret_path;\n    }\n\n    checkInputString(input) {\n        // create Set to represent next states and initialize current Set to initial state\n        let next = new Set();\n        this.current = new Set().add(this.initial);\n\n        // add all epsilon transitons from initial state\n        let eps_trans = this.initial.getEpsilonTrans();\n        if (eps_trans.length != 0) {\n            for (let trans of eps_trans) {\n                next.add(trans.right);\n            }\n            this.current.add(...next);\n        }\n\n        this.setPath.push(this.current);\n\n        // loop through input\n        while (input.length > 0) {\n            let str = input.substring(0, 1);\n            input = input.substring(1);\n            let next = new Set();\n\n            for (let a of this.current) {\n                let eps_trans = a.getEpsilonTrans();\n                if (eps_trans.length != 0) {\n                    for (let trans of eps_trans) {\n                        next.add(trans.right);\n                    }\n                }\n                let sym_trans = a.getSymbolTrans(str);\n                if (sym_trans.length != 0) {\n                    for (let trans of sym_trans) {\n                        next.add(trans.right);\n                    }\n                }\n            }\n\n            for (let b of next) {\n                let eps_trans = b.getEpsilonTrans();\n                if (eps_trans != 0) {\n                    for (let trans of eps_trans) {\n                        next.add(trans.right);\n                    }\n                }\n            }\n\n            this.setPath.push(this.current);\n            this.current = next;\n        }\n        return this.acceptString();\n    }\n\n    /*\n    // given a path, checks whether end state is accepting and adds success/fail marker if so\n    acceptString(current, path) {\n        // Check if the current state is an accepting state\n        let ret_path = [...path];\n        for (let i in this.accepting) {\n            let s = this.accepting[i];\n            if (s == current) {\n                // create acceptance visualization and add it to end of path\n                let accept_state = new NFAState(\"üôÇ\");\n                let acceptance = new Pair(\"‚úîÔ∏è\", accept_state);\n                ret_path.push(acceptance);\n                return ret_path;\n            }\n        }\n        // if not accepting, create fail visualization and add it to end of path\n        let fail_state = new NFAState(\"üôÅ\");\n        let failure = new Pair(\"‚ùå\", fail_state);\n        ret_path.push(failure);\n        return ret_path;\n    }\n    \n    // call checkPath\n    checkInputString(input) {\n        console.log(input);\n        // Pass initial state and input as current and create new path starting from initial\n        let init_path = [new Pair(\"\", this.initial)];\n        return this.checkPath(input + \"\\\\\", this.initial, init_path);\n    }\n\n    // recursively check path for acceptance\n    checkPath(input, current, path) {\n        console.log(\"CheckPath: \");\n        console.log(path);\n        // if string is down to the final \"\\\", return the path\n        if (input === \"\\\\\") {\n            // if accepting string, return the path immediately\n            console.log(path);\n            let acceptance = this.acceptString(current, path);\n            console.log(\"Path 2: \")\n            console.log(path);\n            if (acceptance[acceptance.length - 1].right.name == \"üôÇ\") {\n                return acceptance;\n            }\n\n            // if not accepting, check for any epsilon transitions\n            for (let trans of current.getTrans()) {\n                if (trans.left == \"eps\") {\n                    path.push(trans);\n                    return this.checkPath(input, trans.right, path);\n                }\n            }\n\n            return acceptance;\n        } \n        \n        // Take first char of string, check transitions for match, update to new state and repeat when found\n        let str = input.substring(0, 1);\n        // input string fails if a character is not in alphabet\n        if (!this.syms.has(str)) {\n            window.alert(\"Character \" + str + \" is not in alphabet\");\n            return null;\n        }\n        \n        // Check each transition in the list, if symbol matches or epsilon, recur on the next step down the path\n        for (let trans of current.getTrans()) {\n            console.log(\"Trans: \" + trans);\n            if (str == trans.left) {\n                path.push(trans);\n                return this.checkPath(input.substring(1), trans.right, path);\n            }\n            if (trans.left == \"eps\") {\n                path.push(trans);\n                return this.checkPath(input, trans.right, path);\n            }\n        }\n    } */\n\n    // Checks alphabet for repeated symbols or being empty\n    checkAlphabet() {\n        if (this.alphabet.size === 0) {\n            this.error = \"Empty alphabet\";\n            return false;\n        }\n\n        let symbols = new Set();\n        symbols.add(\"eps\");\n        for (let i in this.alphabet) {\n            let s = this.alphabet[i];\n            if (symbols.has(s)) {\n                this.error = \"Duplicate in alphabet: \" + s;\n                return false;\n            }\n            symbols.add(s);\n        }\n\n        this.syms = symbols;\n        return true;\n    }\n\n    // Checks states for repeats or conflicts with alphabet\n    checkStates() {\n        if (this.all.size === 0) {\n            this.error = \"Empty States\";\n            return false;\n        }\n\n        let states = new Map();\n        for (let i in this.all) {\n            let s = this.all[i];\n            if (states.has(s.name) || this.syms.has(s.name)) {\n                this.error = \"Conflicting state name: \" + s.name;\n                return false;\n            }\n            states.set(s.name, s);\n        }\n\n        this.states = states;\n        return true;\n    }\n\n    // Checks that initial state is a valid state and assigns it\n    checkInitial(initial) {\n        if (this.states.has(initial)) {\n            this.initial = this.states.get(initial);\n            this.initial.connected = true;\n            return true;\n        }\n        this.error = \"Invalid initial state\";\n        return false;\n    }\n\n    // Checks that accepting states are present and valid\n    checkAccepting(accepting) {\n        let acc_array = parseAlphabet(accepting);\n        if (acc_array.size === 0) {\n            this.error = \"Empty accepting states\";\n            return false;\n        }\n\n        for (let i in acc_array) {\n            let acc_name = acc_array[i];\n            if (!this.states.has(acc_name)) {\n                this.error = \"Accepting state \" + acc_name + \" does not exist\";\n                return false;\n            }\n            this.states.get(acc_name).accepting = true;\n            this.accepting.push(this.states.get(acc_name));\n        }\n        return true;\n    }\n\n    // Checks that transitions are valid symbols/states/states\n    // Sets up connections to check all states are connected\n    checkTransitions() {\n        if (this.transitions.size === 0) {\n            this.error = \"Empty transitions\";\n            return false;\n        }\n\n        for (let i in this.transitions) {\n            let t = this.transitions[i];\n\n            // confirm that the symbol and source/dest states exist \n            if (!this.syms.has(t.symbol)) {\n                this.error = \"Invalid symbol in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n                return false;\n            }\n            if (!this.states.has(t.source)) {\n                this.error = \"Invalid source in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n                return false;\n            }\n            if (!this.states.has(t.dest)) {\n                this.error = \"Invalid destination in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n                return false;\n            }\n\n            t.source = this.states.get(t.source);\n            t.dest = this.states.get(t.dest);\n\n            let src_state = t.source;\n            for (let j in src_state.getAllTrans()) {\n                let ts = src_state.getAllTrans()[j];\n                if ((ts.left == t.symbol) && (ts.right == t.dest)) {\n                    // duplicate transition\n                    this.error = \"Transition (\" + t.symbol + \", \" + t.source.name + \", \" + t.dest.name + \") already exists\";\n                    return false;\n                }\n            }\n            src_state.addTrans(t.symbol, t.dest);\n\n            // add for connection check\n            if (!t.source.conn.includes(t.dest)) {\n                t.source.conn.push(t.dest);\n            }\n        }\n        return true;\n    }\n\n    // uses conn lists in states to set connected to bool value\n    makeConnected(start) {\n        for (let i in start.conn) {\n            let s = start.conn[i];\n            if (!s.connected) {\n                s.connected = true;\n                this.makeConnected(s);\n            }\n        }\n    }\n}\n\n// parse states string input into NFAState array\nexport function parseNFAStates(input) {\n    let input_array = input.split(',');\n    let states_array = [];\n    for (let i in input_array) {\n        let str_state = input_array[i];\n        states_array[i] = new NFAState(str_state.replace(\" \", \"\"));\n    }\n    return states_array;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}