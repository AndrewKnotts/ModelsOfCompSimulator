{"ast":null,"code":"export class State {\n  constructor(name) {\n    this.name = name;\n    this.accepting = false;\n    this.connected = false;\n    this.conn = [];\n  }\n\n}\nexport class Transition {\n  constructor(symbol, src, dest) {\n    this.symbol = symbol;\n    this.source = src;\n    this.dest = dest;\n  }\n\n  static getDest() {\n    return this.dest;\n  }\n\n}\nexport class DFAModel {\n  constructor(initial, accepting, all_states, alphabet, transitions) {\n    console.log(\"DFA Model:\");\n    this.all = parseStates(all_states);\n    this.initial = null;\n    this.accepting = [];\n    this.alphabet = parseAlphabet(alphabet);\n    this.transitions = parseTransition(transitions);\n    this.current = null;\n    this.syms = null;\n    this.states = null;\n    this.ts = new Map();\n    this.error = null;\n    this.acceptance_result = null;\n    /* console.log(\"initial: \", initial);\n    console.log(\"accepting: \", accepting);\n    console.log(\"states: \", all_states);\n    console.log(\"alphabet: \", alphabet);\n    console.log(\"transitions: \", transitions); */\n    // check components and alert if error\n\n    if (!this.checkAlphabet()) {\n      window.alert(this.error);\n    } else if (!this.checkStates()) {\n      window.alert(this.error);\n    } else if (!this.checkInitial(initial)) {\n      window.alert(this.error);\n    } else if (!this.checkAccepting(accepting)) {\n      window.alert(this.error);\n    } else if (!this.checkTransitions()) {\n      window.alert(this.error);\n    } else {\n      // make Connected for all and check\n      this.makeConnected(this.initial);\n\n      for (let i in this.all) {\n        let s = this.all[i];\n\n        if (!s.connected) {\n          console.log(\"State \" + s.name + \" is not reachable.\");\n        }\n      }\n    }\n  } // given a path, checks whether end state is accepting and adds success/fail marker if so\n\n\n  acceptString(path) {\n    // Check if the current state is an accepting state\n    for (let i in this.accepting) {\n      let s = this.accepting[i];\n\n      if (s == this.current) {\n        // create acceptance visualization and add it to end of path\n        let accept_state = new State(\"üôÇ\");\n        let acceptance = new Transition(\"‚úîÔ∏è\", null, accept_state);\n        path.push(acceptance);\n        this.acceptance_result = true;\n        return path;\n      }\n    } // if not accepting, create fail visualization and add it to end of path\n\n\n    let fail_state = new State(\"üôÅ\");\n    let failure = new Transition(\"‚ùå\", null, fail_state);\n    path.push(failure);\n    this.acceptance_result = false;\n    return path;\n  } // Takes input string and runs it through model, returning list of transitions to acceptance or null for failure\n\n\n  checkInputString(input) {\n    // Set current state to initial and create new path starting from initial\n    this.current = this.initial;\n    let path = []; // Iterate through each char in string, check transitions for match, update to new state and repeat when found\n\n    for (let i = 0; i < input.length; i++) {\n      let str = input.substring(i, i + 1); // input string fails if a character is not in alphabet\n\n      if (!this.syms.has(str)) {\n        window.alert(\"Character \" + str + \" is not in alphabet\");\n        return null;\n      } //let worked = false;\n\n\n      for (let i in this.transitions) {\n        let t = this.transitions[i];\n\n        if (t.source === this.current && t.symbol === str) {\n          path.push(t);\n          this.current = t.dest; //worked = true;\n\n          break;\n        }\n      }\n      /* if (!worked) {\n          let fail_state = new State(\"üôÅ\");\n          let failure = new Transition(str, null, fail_state);\n          path.push(failure);\n          return path;\n      } */\n\n    }\n\n    return this.acceptString(path);\n  } // Checks alphabet for repeated symbols or being empty\n\n\n  checkAlphabet() {\n    if (this.alphabet.length === 0) {\n      this.error = \"Empty alphabet\";\n      return false;\n    } // Add each character to a set, checking for duplicates\n\n\n    let symbols = new Set();\n\n    for (let i in this.alphabet) {\n      let s = this.alphabet[i];\n\n      if (symbols.has(s)) {\n        this.error = \"Duplicate in alphabet: \" + s;\n        return false;\n      }\n\n      symbols.add(s);\n    }\n\n    this.syms = symbols;\n    return true;\n  } // Checks states for repeats or conflicts with alphabet\n\n\n  checkStates() {\n    if (this.all.length === 0) {\n      this.error = \"Empty States\";\n      return false;\n    } // map state names to state object, checking for duplicates or conflict with alphabet\n\n\n    let states = new Map();\n\n    for (let i in this.all) {\n      let s = this.all[i];\n\n      if (states.has(s.name) || this.syms.has(s.name)) {\n        this.error = \"Conflicting state name: \" + s.name;\n        return false;\n      }\n\n      states.set(s.name, s);\n    }\n\n    this.states = states;\n    return true;\n  } // Checks that initial state is a valid state and assigns it\n\n\n  checkInitial(initial) {\n    if (this.states.has(initial)) {\n      this.initial = this.states.get(initial);\n      this.initial.connected = true;\n      return true;\n    }\n\n    this.error = \"Invalid initial state\";\n    return false;\n  } // Checks that accepting states are present and valid\n\n\n  checkAccepting(accepting) {\n    let acc_array = parseAlphabet(accepting);\n\n    if (acc_array.length === 0) {\n      this.error = \"Empty accepting states\";\n      return false;\n    }\n\n    for (let i in acc_array) {\n      let acc_name = acc_array[i];\n\n      if (!this.states.has(acc_name)) {\n        this.error = \"Accepting state \" + acc_name + \" does not exist\";\n        return false;\n      }\n\n      this.states.get(acc_name).accepting = true;\n      this.accepting.push(this.states.get(acc_name));\n    }\n\n    return true;\n  } // Checks that transitions are valid symbols/states/states\n  // Sets up connections to check all states are connected\n  // ts is a map of Sources to a list of symbols that have been assigned a transition\n\n\n  checkTransitions() {\n    if (this.transitions.length === 0) {\n      this.error = \"Empty transitions\";\n      return false;\n    }\n\n    for (let i in this.transitions) {\n      let t = this.transitions[i]; // confirm that the symbol and source/dest states exist \n\n      if (!this.syms.has(t.symbol)) {\n        this.error = \"Invalid symbol in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n        return false;\n      }\n\n      if (!this.states.has(t.source)) {\n        this.error = \"Invalid source in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n        return false;\n      }\n\n      if (!this.states.has(t.dest)) {\n        this.error = \"Invalid destination in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n        return false;\n      } // reassign t.source/dest from string names to the actual states\n\n\n      t.source = this.states.get(t.source);\n      t.dest = this.states.get(t.dest); // fails if source already has the symbol; else add it to the sym_list or create a new sym_list for it\n\n      if (this.ts.has(t.source) && this.ts.get(t.source).includes(t.symbol)) {\n        this.error = \"State \" + t.source.name + \" has multiple transitions for symbol \" + t.symbol;\n        return false;\n      } else if (this.ts.has(t.source)) {\n        let sym_list = this.ts.get(t.source);\n        sym_list.push(t.symbol);\n        this.ts.set(t.source, sym_list);\n      } else {\n        let new_list = new Array(t.symbol);\n        this.ts.set(t.source, new_list);\n      } // add the dest to the source state for connection check\n\n\n      if (!t.source.conn.includes(t.dest)) {\n        t.source.conn.push(t.dest);\n      }\n    } // check that all states have all alphabet symbols represented\n\n\n    for (let i in this.all) {\n      let s = this.states.get(this.all[i].name); // fails if a state is missing from the transitions map \n\n      if (!this.ts.has(s)) {\n        this.error = \"State \" + s.name + \" has no transitions\";\n        return false;\n      }\n    }\n\n    for (let trans of this.ts.keys()) {\n      for (let sym of this.syms) {\n        // fails if a symbol is missing from a state\n        if (!this.ts.get(trans).includes(sym)) {\n          this.error = \"State \" + trans.name + \" has no transition for symbol \" + sym;\n          return false;\n        }\n      }\n    }\n\n    return true;\n  } // uses conn lists in states to set connected to bool value\n\n\n  makeConnected(start) {\n    for (let i in start.conn) {\n      let s = start.conn[i];\n\n      if (!s.connected) {\n        s.connected = true;\n        this.makeConnected(s);\n      }\n    }\n  }\n\n} // parse alphabet string input into String array\n\nexport function parseAlphabet(input) {\n  input = input.replaceAll(\" \", \"\");\n  if (input.length == 0) return [];\n  let alphabet_array = input.split(',');\n\n  for (let i in alphabet_array) {\n    let alpha = alphabet_array[i];\n    alphabet_array[i] = alpha;\n  }\n\n  return alphabet_array;\n} // parse states string input into State array\n\nexport function parseStates(input) {\n  input = input.replaceAll(\" \", \"\");\n  if (input.length == 0) return [];\n  let input_array = input.split(',');\n  let states_array = [];\n\n  for (let i in input_array) {\n    let str_state = input_array[i];\n    states_array[i] = new State(str_state);\n  }\n\n  return states_array;\n} // parse transition string input into Transition array\n\nexport function parseTransition(input) {\n  input = input.replaceAll(\" \", \"\");\n  if (input.length == 0) return [];\n  let transitions = input.split(';');\n  let trans_array = [];\n\n  for (let i in transitions) {\n    let trans = transitions[i];\n    let split = trans.split(',');\n\n    for (let j in split) {\n      split[j] = split[j].replaceAll(\"(\", \"\").replaceAll(\")\", \"\");\n    }\n\n    trans_array[i] = new Transition(split[0], split[1], split[2]);\n  }\n\n  return trans_array;\n}","map":{"version":3,"names":["State","constructor","name","accepting","connected","conn","Transition","symbol","src","dest","source","getDest","DFAModel","initial","all_states","alphabet","transitions","console","log","all","parseStates","parseAlphabet","parseTransition","current","syms","states","ts","Map","error","acceptance_result","checkAlphabet","window","alert","checkStates","checkInitial","checkAccepting","checkTransitions","makeConnected","i","s","acceptString","path","accept_state","acceptance","push","fail_state","failure","checkInputString","input","length","str","substring","has","t","symbols","Set","add","set","get","acc_array","acc_name","includes","sym_list","new_list","Array","trans","keys","sym","start","replaceAll","alphabet_array","split","alpha","input_array","states_array","str_state","trans_array","j"],"sources":["/Users/simonlow/Documents/ModelsOfCompSimulator-2/client/src/components/input/DFAModel.js"],"sourcesContent":["export class State {\n    constructor(name) {\n        this.name = name;\n        this.accepting = false;\n        this.connected = false;\n        this.conn = [];\n    }\n}\n\nexport class Transition {\n    constructor(symbol, src, dest) {\n        this.symbol = symbol;\n        this.source = src;\n        this.dest = dest;\n    }\n\n    static getDest() {\n        return this.dest;\n    }\n}\n\nexport class DFAModel {\n    constructor(initial, accepting, all_states, alphabet, transitions) {\n        console.log(\"DFA Model:\");\n        this.all = parseStates(all_states);\n        this.initial = null;\n        this.accepting = [];\n        this.alphabet = parseAlphabet(alphabet);\n        this.transitions = parseTransition(transitions);\n        this.current = null;\n        this.syms = null;\n        this.states = null;\n        this.ts = new Map();\n        this.error = null;\n        this.acceptance_result = null;\n        \n        /* console.log(\"initial: \", initial);\n        console.log(\"accepting: \", accepting);\n        console.log(\"states: \", all_states);\n        console.log(\"alphabet: \", alphabet);\n        console.log(\"transitions: \", transitions); */\n\n        // check components and alert if error\n        if (!this.checkAlphabet()) {\n            window.alert(this.error);\n        } else if (!this.checkStates()) {\n            window.alert(this.error);\n        } else if (!this.checkInitial(initial)) {\n            window.alert(this.error);\n        } else if (!this.checkAccepting(accepting)) {\n            window.alert(this.error);\n        } else if (!this.checkTransitions()) {\n            window.alert(this.error);\n        } else {\n            // make Connected for all and check\n            this.makeConnected(this.initial);\n            for (let i in this.all) {\n                let s = this.all[i];\n                if (!s.connected) {\n                    console.log(\"State \" + s.name + \" is not reachable.\");\n                }\n            }\n        }\n    }\n\n    // given a path, checks whether end state is accepting and adds success/fail marker if so\n    acceptString(path) {\n        // Check if the current state is an accepting state\n        for (let i in this.accepting) {\n            let s = this.accepting[i];\n            if (s == this.current) {\n                // create acceptance visualization and add it to end of path\n                let accept_state = new State(\"üôÇ\");\n                let acceptance = new Transition(\"‚úîÔ∏è\", null, accept_state);\n                path.push(acceptance);\n                this.acceptance_result = true;\n                return path;\n            }\n        }\n        // if not accepting, create fail visualization and add it to end of path\n        let fail_state = new State(\"üôÅ\");\n        let failure = new Transition(\"‚ùå\", null, fail_state);\n        path.push(failure);\n        this.acceptance_result = false;\n        return path;\n    }\n\n    // Takes input string and runs it through model, returning list of transitions to acceptance or null for failure\n    checkInputString(input) {\n        // Set current state to initial and create new path starting from initial\n        this.current = this.initial;\n        let path = [];\n\n        // Iterate through each char in string, check transitions for match, update to new state and repeat when found\n        for (let i = 0; i < input.length; i++) {\n            let str = input.substring(i, i + 1);\n            // input string fails if a character is not in alphabet\n            if (!this.syms.has(str)) {\n                window.alert(\"Character \" + str + \" is not in alphabet\");\n                return null;\n            }\n            //let worked = false;\n            for (let i in this.transitions) {\n                let t = this.transitions[i];\n                if ((t.source === this.current) && (t.symbol === str)) {\n                    path.push(t);\n                    this.current = t.dest;\n                    //worked = true;\n                    break;\n                }\n            }\n            /* if (!worked) {\n                let fail_state = new State(\"üôÅ\");\n                let failure = new Transition(str, null, fail_state);\n                path.push(failure);\n                return path;\n            } */\n        }\n        return this.acceptString(path);\n    }\n\n    // Checks alphabet for repeated symbols or being empty\n    checkAlphabet() {\n        if (this.alphabet.length === 0){\n            this.error = \"Empty alphabet\";\n            return false;\n        }\n\n        // Add each character to a set, checking for duplicates\n        let symbols = new Set();\n        for (let i in this.alphabet) {\n            let s = this.alphabet[i];\n            if (symbols.has(s)) {\n                this.error = \"Duplicate in alphabet: \" + s;\n                return false;\n            }\n            symbols.add(s);\n        }\n\n        this.syms = symbols;\n        return true;\n    }\n\n    // Checks states for repeats or conflicts with alphabet\n    checkStates() {\n        if (this.all.length === 0) {\n            this.error = \"Empty States\";\n            return false;\n        }\n\n        // map state names to state object, checking for duplicates or conflict with alphabet\n        let states = new Map();\n        for (let i in this.all) {\n            let s = this.all[i];\n            if (states.has(s.name) || this.syms.has(s.name)) {\n                this.error = \"Conflicting state name: \" + s.name;\n                return false;\n            }\n            states.set(s.name, s);\n        }\n\n        this.states = states;\n        return true;\n    }\n\n    // Checks that initial state is a valid state and assigns it\n    checkInitial(initial) {\n        if (this.states.has(initial)) {\n            this.initial = this.states.get(initial);\n            this.initial.connected = true;\n            return true;\n        }\n        this.error = \"Invalid initial state\";\n        return false;\n    }\n\n    // Checks that accepting states are present and valid\n    checkAccepting(accepting) {\n        let acc_array = parseAlphabet(accepting);\n        if (acc_array.length === 0) {\n            this.error = \"Empty accepting states\";\n            return false;\n        }\n\n        for (let i in acc_array) {\n            let acc_name = acc_array[i];\n            if (!this.states.has(acc_name)) {\n                this.error = \"Accepting state \" + acc_name + \" does not exist\";\n                return false;\n            }\n            this.states.get(acc_name).accepting = true;\n            this.accepting.push(this.states.get(acc_name));\n        }\n        return true;\n    }\n\n    // Checks that transitions are valid symbols/states/states\n    // Sets up connections to check all states are connected\n    // ts is a map of Sources to a list of symbols that have been assigned a transition\n    checkTransitions() {\n        if (this.transitions.length === 0) {\n            this.error = \"Empty transitions\";\n            return false;\n        }\n\n        for (let i in this.transitions) {\n            let t = this.transitions[i];\n\n            // confirm that the symbol and source/dest states exist \n            if (!this.syms.has(t.symbol)) {\n                this.error = \"Invalid symbol in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n                return false;\n            }\n            if (!this.states.has(t.source)) {\n                this.error = \"Invalid source in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n                return false;\n            }\n            if (!this.states.has(t.dest)) {\n                this.error = \"Invalid destination in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n                return false;\n            }\n\n            // reassign t.source/dest from string names to the actual states\n            t.source = this.states.get(t.source);\n            t.dest = this.states.get(t.dest);\n\n            // fails if source already has the symbol; else add it to the sym_list or create a new sym_list for it\n            if (this.ts.has(t.source) && this.ts.get(t.source).includes(t.symbol)) {\n                this.error = \"State \" + t.source.name + \" has multiple transitions for symbol \" + t.symbol;\n                return false;\n            } else if (this.ts.has(t.source)) {\n                let sym_list = this.ts.get(t.source);\n                sym_list.push(t.symbol);\n                this.ts.set(t.source, sym_list);\n            } else {\n                let new_list = new Array(t.symbol);\n                this.ts.set(t.source, new_list);\n            }\n\n            // add the dest to the source state for connection check\n            if (!t.source.conn.includes(t.dest)) {\n                t.source.conn.push(t.dest);\n            }\n        }\n\n        // check that all states have all alphabet symbols represented\n        for (let i in this.all) {\n            let s = this.states.get(this.all[i].name);\n            // fails if a state is missing from the transitions map \n            if (!this.ts.has(s)) {\n                this.error = \"State \" + s.name + \" has no transitions\";\n                return false;\n            }\n        }\n\n        for (let trans of this.ts.keys()) {\n            for (let sym of this.syms) {\n                // fails if a symbol is missing from a state\n                if (!this.ts.get(trans).includes(sym)) {\n                    this.error = \"State \" + trans.name + \" has no transition for symbol \" + sym;\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    // uses conn lists in states to set connected to bool value\n    makeConnected(start) {\n        for (let i in start.conn) {\n            let s = start.conn[i];\n            if (!s.connected) {\n                s.connected = true;\n                this.makeConnected(s);\n            }\n        }\n    }\n}\n\n// parse alphabet string input into String array\nexport function parseAlphabet(input) {\n    input = input.replaceAll(\" \",\"\");\n    if (input.length == 0) return [];\n\n    let alphabet_array = input.split(',');\n    for (let i in alphabet_array) {\n        let alpha = alphabet_array[i];\n        alphabet_array[i] = alpha;\n    }\n    return alphabet_array;\n}\n\n// parse states string input into State array\nexport function parseStates(input) {\n    input = input.replaceAll(\" \",\"\");\n    if (input.length == 0) return [];\n\n    let input_array = input.split(',');\n    let states_array = [];\n    for (let i in input_array) {\n        let str_state = input_array[i];\n        states_array[i] = new State(str_state);\n    }\n    return states_array;\n}\n\n// parse transition string input into Transition array\nexport function parseTransition(input) {\n    input = input.replaceAll(\" \",\"\");\n    if (input.length == 0) return [];\n\n    let transitions = input.split(';');\n    let trans_array = [];\n    for (let i in transitions) {\n        let trans = transitions[i];\n        let split = trans.split(',');\n        for (let j in split) {\n            split[j] = split[j].replaceAll(\"(\", \"\").replaceAll(\")\", \"\");\n        }\n        trans_array[i] = new Transition(split[0], split[1], split[2]);\n    }\n    return trans_array;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}