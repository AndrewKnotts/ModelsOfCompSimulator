{"ast":null,"code":"var inputAlphabet = \"\";\nvar pushdownAlphabet = \"\";\nvar states = \"\";\nvar transitions = \"\";\nvar stack = \"\";\nvar initialState = \"\";\nvar final = \"\";\nvar model = \"\";\nvar initialStack = \"\"; // leftmost char will be top of stack\n\nvar all = \"\";\n\nfunction parseStates(input) {\n  //console.log(\"Parsing States\");\n  let input_array = input.split(',');\n  let states_array = [];\n\n  for (let i in input_array) {\n    let str_state = input_array[i];\n    states_array[i] = new State(str_state.replace(\" \", \"\"));\n  }\n\n  return states_array;\n}\n\nfunction parseInputAlphabet(input) {\n  //console.log(\"Paring Input Alphabet\");\n  let inputAlphabet_array = input.split(',');\n\n  for (let i in inputAlphabet_array) {\n    let alpha = inputAlphabet_array[i];\n    inputAlphabet_array[i] = alpha.replace(\" \", \"\");\n  }\n\n  return inputAlphabet_array;\n}\n\nfunction parsePushdownAlphabet(input) {\n  console.log(\"parsing pushdown alphabet: \" + input);\n  let pushdownAlphabet_array = input.split(',');\n\n  for (let i in pushdownAlphabet_array) {\n    let alpha = pushdownAlphabet_array[i];\n    pushdownAlphabet_array[i] = alpha.replace(\" \", \"\");\n  }\n\n  return pushdownAlphabet_array;\n} // (q0, a, S) -> (q1, S); (q1, e, S) -> (q2, SS); ...\n\n\nfunction parseTransitions(input) {\n  //console.log(\"Parsing Transitions\");\n  let transitions = input.split(';');\n  let transArray = [];\n\n  for (let i in transitions) {\n    let pair = transitions[i].split(\" -> \");\n    let src = pair[0].split(','); //(q0, a, Z)\n\n    let dest = pair[1].split(','); // (q1, A)\n\n    for (let j in src) {\n      src[j] = src[j].replace(\" \", \"\").replace(\"(\", \"\").replace(\")\", \"\");\n    }\n\n    dest[0] = dest[0].replace(\" \", \"\").replace(\"(\", \"\");\n    dest[1] = dest[1].replace(\" \", \"\").replace(\")\", \"\");\n    let state1 = new State(src[0]);\n    let state2 = new State(dest[0]);\n    transArray[i] = new Transition(state1, state2, src[1], src[2], dest[1]);\n  }\n\n  return transArray;\n}\n\nexport class State {\n  // same as DFA\n  constructor(name) {\n    this.name = name;\n    this.accepting = false;\n    this.connected = false;\n    this.conn = [];\n  }\n\n}\nexport class Transition {\n  // (source, input, stack0) -> (dest, stack1)\n  constructor(source, dest, input, stack0, stack1) {\n    this.input = input;\n    this.source = source;\n    this.dest = dest;\n    this.stack0 = stack0;\n    this.stack1 = stack1;\n  }\n\n  static getDest() {\n    return this.dest;\n  }\n\n}\nexport class PDAModel {\n  constructor(all_states, initialState, inputAlphabet, pushdownAlphabet, transitions, initialStack, accepting) {\n    this.all = parseStates(all_states);\n    this.pushdownAlphabet = parsePushdownAlphabet(pushdownAlphabet);\n    this.transitions = parseTransitions(transitions);\n    this.inputAlphabet = parseInputAlphabet(inputAlphabet);\n    this.initialStack = initialStack;\n    this.accepting = parseStates(accepting);\n    this.inputSyms = null;\n    this.pdSyms = null; //this.ts = new Map();\n\n    this.srcToInput = new Map();\n    this.srcToStack = new Map();\n    this.currentState = null;\n    this.currentStack = null;\n    this.epsTransitions = [];\n    if (!this.checkInputAlphabet()) window.alert(\"Invalid Input Alphabet\"); //console.log(this.pushdownAlphabet.size);\n\n    if (!this.checkPushdownAlphabet()) window.alert(\"Invalid Pushdown alphabet: \" + pushdownAlphabet); //console.log(\"here\");\n\n    if (!this.checkInitialStack()) window.alert(\"Invalid Initial Stack\");\n    if (!this.checkStates()) window.alert(\"Invalid states\"); //if (!this.checkInitialState()) console.log(\"Invalid initial state\");\n    //else {\n    //   this.initialState = this.getInitialState(initialState);\n    //}\n\n    if (!this.getInitialState(initialState)) window.alert(\"Invalid Initial State\");\n    if (!this.checkAccepting()) window.alert(\"Invalid Accepting array\");\n    if (!this.checkTransitions()) window.alert(\"Invalid transitions\"); //if (!this.checkDeterministic()) console.log(\"Non-deterministic\");\n    //else console.log(\"Deterministic\");\n\n    if (states.length > 1) {\n      this.makeConnected(this.initialState);\n\n      for (let i in this.all) {\n        let s = this.all[i];\n\n        if (!s.connected) {\n          console.log(\"State \" + s.name + \" is not reachable.\");\n        }\n      }\n    }\n  }\n\n  getInitialState(name) {\n    if (name == null || name == \"\") return false;\n\n    for (let i in this.all) {\n      let st = this.all[i];\n\n      if (st.name === name) {\n        this.initialState = st;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  checkInputString(input) {\n    this.currentState = this.initialState;\n    this.currentStack = this.initialStack;\n    let path = []; // path is gonna have each transition object\n\n    for (let i = 0; i < input.length; i++) {\n      let sym = input.substring(i, i + 1);\n      let worked = false;\n      let epsTran = null;\n\n      for (let j in this.transitions) {\n        let t = this.transitions[j];\n        let currStackChar = t.stack0 === \"eps\" ? \"\" : t.stack0;\n\n        if (t.source === this.currentState && t.input === sym && currStackChar === this.currentStack.substring(0, 1)) {\n          path.push(t);\n          this.currentState = t.dest;\n          if (t.stack1 != \"eps\") this.currentStack = t.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n          worked = true;\n          break;\n        } else if (t.input == \"eps\" && t.source == this.currentState && t.stack0 == this.currentStack.substring(0, 1)) {\n          epsTran = t;\n        }\n      }\n\n      if (!worked && epsTran != null) {\n        path.push(epsTran);\n        this.currentState = epsTran.dest;\n        if (epsTran.stack1 != \"eps\") this.currentStack = epsTran.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n        i--;\n      } else if (!worked) {\n        window.alert(\"No transition suitable\");\n        return false;\n      }\n    }\n\n    while (this.currentStack != \"\") {\n      let worked = false;\n\n      for (let j in this.epsTransitions) {\n        let et = this.epsTransitions[j];\n\n        if (et.source === this.currentState && this.currentStack.substring(0, 1) === et.stack0) {\n          path.push(et);\n          this.currentState = et.dest;\n          if (et.stack1 != \"eps\") this.currentStack = et.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n          worked = true;\n        }\n      }\n\n      if (!worked) {\n        window.alert(\"non-empty stack\");\n        return false;\n      }\n    }\n\n    let endState = false;\n\n    for (let i in this.accepting) {\n      let s = this.accepting[i];\n\n      if (s.name === this.currentState.name) {\n        endState = true;\n        break;\n      }\n    }\n\n    if (endState) return path;else {\n      window.alert(\"Not in end state\");\n      return false;\n    }\n  }\n\n  checkInputAlphabet() {\n    if (this.inputAlphabet.size === 0) return false;\n    let symbols = new Set();\n\n    for (let s in this.inputAlphabet) {\n      let i = this.inputAlphabet[s];\n      if (symbols.has(i)) return false;\n      symbols.add(i);\n    }\n\n    this.inputSyms = symbols;\n    return true;\n  }\n\n  checkPushdownAlphabet() {\n    if (this.pushdownAlphabet.size == 0) return false;\n    let symbols = new Set();\n\n    for (let s in this.pushdownAlphabet) {\n      let i = this.pushdownAlphabet[s];\n      if (symbols.has(i) || this.inputSyms.has(i)) return false;\n      symbols.add(i);\n    }\n\n    this.pdSyms = symbols; //console.log(this.pdSyms.size());\n\n    return true;\n  }\n\n  checkStates() {\n    if (this.all.size == 0) return false;\n    let states = new Map();\n\n    for (let i in this.all) {\n      let s = this.all[i];\n      if (states != null && (states.has(s.name) || this.pdSyms.has(s.name) || this.inputSyms.has(s.name))) return false;\n      states.set(s.name, s);\n    }\n\n    this.states = states;\n    return true;\n  }\n\n  checkInitialState() {\n    if (this.states.has(this.initialState.name)) {\n      //this.initialState = this.states.has(initialState.name);\n      this.initialState.connected = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  checkInitialStack() {\n    console.log(this.initialStack);\n\n    for (let i in initialStack) {\n      let sym = initialStack.substring(i, i + 1);\n\n      if (!this.pdSyms.has(sym)) {\n        //this.initialStack = this.pdSyms.get(initialStack)\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  checkAccepting() {\n    for (let i in all) {\n      let s = all[i];\n      if (!this.states.has(s)) return false;\n      s.accepting = true;\n      this.accepting.push(s);\n    }\n\n    return true;\n  }\n\n  checkTransitions() {\n    if (this.transitions.size === 0) return false;\n\n    for (let i in this.transitions) {\n      let t = this.transitions[i];\n      if (t.input != \"eps\" && !this.inputSyms.has(t.input)) return false; // must accept empty\n\n      if (t.stack0 != \"eps\" && !this.pdSyms.has(t.stack0)) return false;\n      let st = false;\n      let end = false;\n\n      for (let x in this.all) {\n        let cc = this.all[x];\n        if (st && end) break;\n\n        if (cc.name === t.source.name) {\n          st = true;\n          t.source = cc;\n        }\n\n        if (cc.name === t.dest.name) {\n          end = true;\n          t.dest = cc;\n        }\n      }\n\n      if (!(st && end)) return false; // check new stack:\n\n      if (t.stack1 != \"eps\") {\n        for (let x in t.stack1) {\n          let c = t.stack1.substring(x, x + 1);\n          if (!this.pdSyms.has(c)) return false;\n        }\n      }\n\n      if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input) && this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n        return false;\n      } // doesn't have the stack symbol yet\n      else if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input)) {\n        let symList = this.srcToInput.get(t.source);\n        symList.push(t.input);\n        this.srcToInput.set(t.source, symList);\n      } // doesnt have the input symbol yet\n      else if (this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n        let symList = this.srcToStack.get(t.source);\n        symList.push(t.stack0);\n        this.srcToStack.set(t.source, symList);\n      } // has the source, but neither the symbol nor the input\n      else if (this.srcToStack.has(t.source) && this.srcToInput.has(t.source)) {\n        let inList = this.srcToInput.get(t.source);\n        inList.push(t.input);\n        this.srcToInput.set(t.source, inList);\n        let stackList = this.srcToStack.get(t.source);\n        stackList.push(t.stack0);\n        this.srcToStack.set(t.source, inList);\n      } // state has yet to be recorded as a source\n      else {\n        let inList = new Array(t.input);\n        let stList = new Array(t.stack0);\n        this.srcToInput.set(t.source, inList);\n        this.srcToStack.set(t.source, stList);\n      }\n\n      if (!t.source.conn.includes(t.dest) && t.source.name != t.dest.name) {\n        t.source.conn.push(t.dest);\n        t.source.connected = true;\n        if (t.source.name === this.initialState.name) this.initialState = t.source;\n      } // Adding to list of Transitions with eps as input\n\n\n      if (t.input === \"eps\") {\n        this.epsTransitions.push(t);\n      }\n    }\n\n    return true;\n  }\n\n  makeConnected(start) {\n    for (let i in start.conn) {\n      let s = start.conn[i];\n\n      if (!s.connected) {\n        s.connected = true;\n        this.makeConnected(s);\n      }\n    }\n  }\n\n}\nlet states1 = \"q0, q1\";\nlet startState1 = \"q0\";\nlet inputAlphabet1 = \"a, b\";\nlet pushdownAlphabet1 = \"A, Z\";\nlet transitions1 = \"(q0, a, Z) -> (q0, AZ); (q0, a, A) -> (q0, AA); (q0, b, A) -> (q1, eps); (q1, b, A) -> (q1, eps); (q1, eps, Z) -> (q1, eps)\";\nlet startStack1 = \"Z\";\nlet accepting1 = \"q1\";\nlet astring1 = \"aaabbb\"; // Z\n\nlet astring2 = \"aaaabbbb\"; // Z\n\nlet astring3 = \"abbb\"; // AZAZ\n\nlet astring4 = \"bbbbb\"; // AAAAA\n\nlet astring5 = \"bbb\"; // AZAZAZZZZ\n\nlet rstring1 = \"aabbba\"; // A, Z, AAZ\n\nlet rstring2 = \"\"; // anything: A, Z, AA, AAZZ\n\nlet rstring3 = \"ab\"; // Z\n\nlet rstring4 = \"a\"; // Z, A\n\nlet rstring5 = \"aaabbb\"; // AA, A\n\n/*\nlet Z_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"Z\", accepting1);\nlet A_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"A\", accepting1);\nlet AA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AA\", accepting1);\nlet AAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAZ\", accepting1);\nlet AZAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZ\", accepting1);\nlet AAAAA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAAAA\", accepting1);\nlet AZAZAZZZZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZAZZZZ\", accepting1);\n*/\n\n/* TESTS: change return statement of checkInputString from return path; to return true; to test again\n// Accept\nif (Z_PDA.checkInputString(\"aaabbb\")) console.log(\"test1: correct output - passed\");\nelse console.log(\"test1: failed\");\n\nif (Z_PDA.checkInputString(astring2)) console.log(\"test2: correct output - passed\")\nelse console.log(\"test2: failed\");\n\n//Wrong test here\nif (AZAZ_PDA.checkInputString(\"abbb\")) console.log(\"test3: correct output - passed\");\nelse console.log(\"test3: failed\"); \n\nif (AAAAA_PDA.checkInputString(\"bbbbb\")) console.log(\"test4: correct output - passed\");\nelse console.log(\"test4: failed\");\n\nif (AZAZAZZZZ_PDA.checkInputString(\"bbb\")) console.log(\"test5: correct output - passed\");\nelse console.log(\"test5: failed\"); \n\nif (Z_PDA.checkInputString(\"ab\")) console.log(\"test13: correct output - passed\");\nelse console.log(\"test13: failed\");\n\nif (A_PDA.checkInputString(\"aaabbbb\")) console.log(\"test16: correct output - passed\");\nelse console.log(\"test16: failed\");\n\n// Reject\nif (!A_PDA.checkInputString(\"aabbba\")) console.log(\"test6: correct output - rejected\");\nelse console.log(\"test6: failed\");\n\nif (!Z_PDA.checkInputString(\"aabbba\")) console.log(\"test7: correct output - rejected\");\nelse console.log(\"test7: failed\");\n\nif (!AAZ_PDA.checkInputString(\"aabbba\")) console.log(\"test8: correct output - rejected\");\nelse console.log(\"test8: failed\");\n\nif (!A_PDA.checkInputString(\"\")) console.log(\"test9: correct output - rejected\");\nelse console.log(\"test9: failed\");\n\nif (!Z_PDA.checkInputString(\"\")) console.log(\"test10: correct output - rejected\");\nelse console.log(\"test10: failed\");\n\nif (!AAZ_PDA.checkInputString(\"\")) console.log(\"test11: correct output - rejected\");\nelse console.log(\"test11: failed\");\n\nif (!AAAAA_PDA.checkInputString(\"\")) console.log(\"test12: correct output - rejected\");\nelse console.log(\"test12: failed\");\n\nif (!Z_PDA.checkInputString(\"a\")) console.log(\"test14: correct output - rejected\");\nelse console.log(\"test14: failed\");\n\nif (!A_PDA.checkInputString(\"a\")) console.log(\"test15: correct output - rejected\");\nelse console.log(\"test15: failed\");\n\nif (!AA_PDA.checkInputString(\"aaabbbb\")) console.log(\"test17: correct output - rejected\");\nelse console.log(\"test17: failed\");\n*/\n// Palindrome PDA\n\nlet states2 = \"s, f\";\nlet transitions2 = \"(s, a, eps) -> (s, A); (s, b, eps) -> (s, B); (s, c, eps) -> (f, eps); (f, a, A) -> (f, eps); (f, b, B) -> (f, eps)\";\nlet startstate2 = \"s\";\nlet initialStack2 = \"\";\nlet inputAlphabet2 = \"a, b, c\";\nlet pushdownAlphabet2 = \"A, B\";\nlet accepting2 = \"f\"; //let testPDA2 = new PDAModel(states2, startstate2, inputAlphabet2, pushdownAlphabet2, transitions2, initialStack2, accepting2);\n//console.log(testPDA2.checkInputString(\"aaabbb\"));\n//let simplePDA = new PDAModel(\"q0\", \"q0\", \"a,b\", \"A\", \"(q0, a, A) -> (q0, eps); (q0, b, eps) -> (q0, A)\", \"A\", \"q0\");\n//console.log(simplePDA.checkInputString(\"aba\"));","map":{"version":3,"names":["inputAlphabet","pushdownAlphabet","states","transitions","stack","initialState","final","model","initialStack","all","parseStates","input","input_array","split","states_array","i","str_state","State","replace","parseInputAlphabet","inputAlphabet_array","alpha","parsePushdownAlphabet","console","log","pushdownAlphabet_array","parseTransitions","transArray","pair","src","dest","j","state1","state2","Transition","constructor","name","accepting","connected","conn","source","stack0","stack1","getDest","PDAModel","all_states","inputSyms","pdSyms","srcToInput","Map","srcToStack","currentState","currentStack","epsTransitions","checkInputAlphabet","window","alert","checkPushdownAlphabet","checkInitialStack","checkStates","getInitialState","checkAccepting","checkTransitions","length","makeConnected","s","st","checkInputString","path","sym","substring","worked","epsTran","t","currStackChar","push","concat","et","endState","size","symbols","Set","has","add","set","checkInitialState","end","x","cc","c","get","includes","symList","inList","stackList","Array","stList","start","states1","startState1","inputAlphabet1","pushdownAlphabet1","transitions1","startStack1","accepting1","astring1","astring2","astring3","astring4","astring5","rstring1","rstring2","rstring3","rstring4","rstring5","states2","transitions2","startstate2","initialStack2","inputAlphabet2","pushdownAlphabet2","accepting2"],"sources":["/Users/simonlow/Documents/ModelsOfCompSimulator-2/client/src/components/input/PDAModel.js"],"sourcesContent":["var inputAlphabet = \"\"\nvar pushdownAlphabet = \"\"\nvar states = \"\"\nvar transitions = \"\"\nvar stack = \"\"\nvar initialState = \"\"\nvar final = \"\"\nvar model = \"\"\nvar initialStack = \"\" // leftmost char will be top of stack\nvar all = \"\"\n\n\nfunction parseStates(input) {\n    //console.log(\"Parsing States\");\n    let input_array = input.split(',');\n    let states_array = [];\n    for (let i in input_array) {\n        let str_state = input_array[i];\n        states_array[i] = new State(str_state.replace(\" \", \"\"));\n    }\n    return states_array;\n}\n\nfunction parseInputAlphabet(input) {\n    //console.log(\"Paring Input Alphabet\");\n    let inputAlphabet_array = input.split(',');\n    for (let i in inputAlphabet_array) {\n        let alpha = inputAlphabet_array[i];\n        inputAlphabet_array[i] = alpha.replace(\" \", \"\");\n    }\n    return inputAlphabet_array;\n}\n\nfunction parsePushdownAlphabet(input) {\n    console.log(\"parsing pushdown alphabet: \" + input);\n    let pushdownAlphabet_array = input.split(',');\n    for (let i in pushdownAlphabet_array) {\n        let alpha = pushdownAlphabet_array[i];\n        pushdownAlphabet_array[i] = alpha.replace(\" \", \"\");\n    }\n    return pushdownAlphabet_array;\n}\n\n// (q0, a, S) -> (q1, S); (q1, e, S) -> (q2, SS); ...\nfunction parseTransitions(input) {\n    //console.log(\"Parsing Transitions\");\n    let transitions = input.split(';');\n    let transArray = [];\n    for (let i in transitions) {\n        let pair = transitions[i].split(\" -> \");\n        let src = pair[0].split(','); //(q0, a, Z)\n        let dest = pair[1].split(','); // (q1, A)\n\n        for (let j in src) {\n            src[j] = src[j].replace(\" \", \"\").replace(\"(\", \"\").replace(\")\", \"\");\n        }\n        dest[0] = dest[0].replace(\" \", \"\").replace(\"(\", \"\");\n        dest[1] = dest[1].replace(\" \", \"\").replace(\")\", \"\");\n\n        let state1 = new State(src[0]);\n        let state2 = new State(dest[0]);\n\n        transArray[i] = new Transition(state1, state2, src[1], src[2], dest[1]);\n    }\n    return transArray;\n}\n\nexport class State { // same as DFA\n    constructor(name) {\n        this.name = name;\n        this.accepting = false;\n        this.connected = false;\n        this.conn = [];\n    }\n}\n\nexport class Transition { // (source, input, stack0) -> (dest, stack1)\n    constructor(source, dest, input, stack0, stack1) {\n        this.input = input;\n        this.source = source;\n        this.dest = dest;\n        this.stack0 = stack0;\n        this.stack1 = stack1;\n    }\n\n    static getDest() {\n        return this.dest;\n    }\n}\n\nexport class PDAModel {\n    constructor(all_states, initialState, inputAlphabet, pushdownAlphabet, transitions, initialStack, accepting) {\n        this.all = parseStates(all_states);\n        this.pushdownAlphabet = parsePushdownAlphabet(pushdownAlphabet);\n        this.transitions = parseTransitions(transitions);\n        this.inputAlphabet = parseInputAlphabet(inputAlphabet);\n        this.initialStack = initialStack;\n        this.accepting = parseStates(accepting);\n        this.inputSyms = null;\n        this.pdSyms = null;\n        //this.ts = new Map();\n        this.srcToInput = new Map();\n        this.srcToStack = new Map();\n        this.currentState = null;\n        this.currentStack = null;\n        this.epsTransitions = [];\n\n\n\n        if (!this.checkInputAlphabet()) window.alert(\"Invalid Input Alphabet\");\n        //console.log(this.pushdownAlphabet.size);\n        if (!this.checkPushdownAlphabet()) window.alert(\"Invalid Pushdown alphabet: \" + pushdownAlphabet);\n        //console.log(\"here\");\n        if (!this.checkInitialStack()) window.alert(\"Invalid Initial Stack\");\n        if (!this.checkStates()) window.alert(\"Invalid states\");\n        //if (!this.checkInitialState()) console.log(\"Invalid initial state\");\n        //else {\n        //   this.initialState = this.getInitialState(initialState);\n        //}\n        if (!this.getInitialState(initialState)) window.alert(\"Invalid Initial State\");\n        if (!this.checkAccepting()) window.alert(\"Invalid Accepting array\");\n        if (!this.checkTransitions()) window.alert(\"Invalid transitions\");\n        //if (!this.checkDeterministic()) console.log(\"Non-deterministic\");\n        //else console.log(\"Deterministic\");\n\n        if (states.length > 1) {\n            this.makeConnected(this.initialState);\n            for (let i in this.all) {\n                let s = this.all[i];\n                if (!s.connected) {\n                    console.log(\"State \" + s.name + \" is not reachable.\");\n                }\n            }\n        }\n    }\n\n    getInitialState(name) {\n        if (name == null || name == \"\") return false;\n        for (let i in this.all) {\n            let st = this.all[i];\n            if (st.name === name) {\n                this.initialState = st;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    checkInputString(input) {\n        this.currentState = this.initialState;\n        this.currentStack = this.initialStack;\n        let path = []; // path is gonna have each transition object\n\n        for (let i = 0; i < input.length; i++) {\n            let sym = input.substring(i, i + 1);\n            let worked = false;\n            let epsTran = null;\n            for (let j in this.transitions) {\n                let t = this.transitions[j];\n                let currStackChar = (t.stack0 === \"eps\") ? \"\" : t.stack0;\n                if ((t.source === this.currentState) && (t.input === sym) && (currStackChar === this.currentStack.substring(0, 1))) {\n                    path.push(t);\n                    this.currentState = t.dest;\n                    if (t.stack1 != \"eps\") this.currentStack = t.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));\n                    else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n                    worked = true;\n                    break;\n                }\n                else if ((t.input == \"eps\") && (t.source == this.currentState) && (t.stack0 == this.currentStack.substring(0, 1))) {\n                    epsTran = t;\n                }\n            }\n            if (!worked && epsTran != null) {\n                path.push(epsTran);\n                this.currentState = epsTran.dest;\n                if (epsTran.stack1 != \"eps\") this.currentStack = epsTran.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));\n                else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n                i--;\n            }\n            else if (!worked) {\n                window.alert(\"No transition suitable\");\n                return false;\n            }\n        }\n        while (this.currentStack != \"\") {\n            let worked = false;\n            for (let j in this.epsTransitions) {\n                let et = this.epsTransitions[j];\n                if (et.source === this.currentState && this.currentStack.substring(0, 1) === et.stack0) {\n                    path.push(et);\n                    this.currentState = et.dest;\n                    if (et.stack1 != \"eps\") this.currentStack = et.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));\n                    else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n                    worked = true;\n                }\n            }\n            if (!worked) {\n                window.alert(\"non-empty stack\");\n                return false;\n\n            }\n        }\n\n        let endState = false;\n        for (let i in this.accepting) {\n            let s = this.accepting[i];\n            if (s.name === this.currentState.name) {\n                endState = true;\n                break;\n            }\n        }\n\n        if (endState) return path;\n        else {\n            window.alert(\"Not in end state\");\n            return false;\n        }\n    }\n\n    checkInputAlphabet() {\n        if (this.inputAlphabet.size === 0) return false;\n        let symbols = new Set();\n        for (let s in this.inputAlphabet) {\n            let i = this.inputAlphabet[s];\n            if (symbols.has(i)) return false;\n            symbols.add(i);\n        }\n\n        this.inputSyms = symbols;\n        return true;\n    }\n\n    checkPushdownAlphabet() {\n        if (this.pushdownAlphabet.size == 0) return false;\n\n        let symbols = new Set();\n        for (let s in this.pushdownAlphabet) {\n            let i = this.pushdownAlphabet[s];\n            if (symbols.has(i) || this.inputSyms.has(i)) return false;\n            symbols.add(i);\n        }\n\n        this.pdSyms = symbols;\n        //console.log(this.pdSyms.size());\n        return true;\n    }\n\n    checkStates() {\n        if (this.all.size == 0) return false;\n\n        let states = new Map();\n        for (let i in this.all) {\n            let s = this.all[i];\n            if (states != null && (states.has(s.name) || this.pdSyms.has(s.name) || this.inputSyms.has(s.name))) return false;\n            states.set(s.name, s);\n        }\n\n        this.states = states;\n        return true;\n    }\n\n    checkInitialState() {\n        if (this.states.has(this.initialState.name)) {\n            //this.initialState = this.states.has(initialState.name);\n            this.initialState.connected = true;\n            return true;\n        }\n        return false;\n    }\n\n    checkInitialStack() {\n        console.log(this.initialStack);\n        for (let i in initialStack) {\n            let sym = initialStack.substring(i, i + 1);\n            if (!this.pdSyms.has(sym)) {\n                //this.initialStack = this.pdSyms.get(initialStack)\n                return false\n            }\n        }\n\n        return true;\n    }\n\n    checkAccepting() {\n        for (let i in all) {\n            let s = all[i];\n            if (!this.states.has(s)) return false;\n            s.accepting = true;\n            this.accepting.push(s);\n        }\n        return true;\n\n    }\n\n    checkTransitions() {\n        if (this.transitions.size === 0) return false;\n\n        for (let i in this.transitions) {\n            let t = this.transitions[i];\n            if (t.input != \"eps\" && !this.inputSyms.has(t.input)) return false; // must accept empty\n            if (t.stack0 != \"eps\" && !this.pdSyms.has(t.stack0)) return false;\n            let st = false;\n            let end = false;\n            for (let x in this.all) {\n                let cc = this.all[x];\n                if (st && end) break;\n                if (cc.name === t.source.name) {\n                    st = true;\n                    t.source = cc;\n                }\n                if (cc.name === t.dest.name) {\n                    end = true;\n                    t.dest = cc;\n                }\n\n            }\n            if (!(st && end)) return false;\n\n            // check new stack:\n            if (t.stack1 != \"eps\") {\n                for (let x in t.stack1) {\n                    let c = t.stack1.substring(x, x + 1);\n                    if (!this.pdSyms.has(c)) return false;\n                }\n            }\n\n            if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input)\n                && this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n                return false;\n            }\n            // doesn't have the stack symbol yet\n            else if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input)) {\n                let symList = this.srcToInput.get(t.source);\n                symList.push(t.input);\n                this.srcToInput.set(t.source, symList);\n            }\n            // doesnt have the input symbol yet\n            else if (this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n                let symList = this.srcToStack.get(t.source);\n                symList.push(t.stack0);\n                this.srcToStack.set(t.source, symList);\n            }\n            // has the source, but neither the symbol nor the input\n            else if (this.srcToStack.has(t.source) && this.srcToInput.has(t.source)) {\n                let inList = this.srcToInput.get(t.source);\n                inList.push(t.input);\n                this.srcToInput.set(t.source, inList);\n                let stackList = this.srcToStack.get(t.source);\n                stackList.push(t.stack0);\n                this.srcToStack.set(t.source, inList);\n            }\n            // state has yet to be recorded as a source\n            else {\n                let inList = new Array(t.input);\n                let stList = new Array(t.stack0);\n                this.srcToInput.set(t.source, inList);\n                this.srcToStack.set(t.source, stList);\n            }\n\n            if (!t.source.conn.includes(t.dest) && t.source.name != t.dest.name) {\n                t.source.conn.push(t.dest);\n                t.source.connected = true;\n                if (t.source.name === this.initialState.name) this.initialState = t.source;\n            }\n\n            // Adding to list of Transitions with eps as input\n            if (t.input === \"eps\") {\n                this.epsTransitions.push(t);\n            }\n        }\n        return true;\n    }\n\n    makeConnected(start) {\n        for (let i in start.conn) {\n            let s = start.conn[i];\n            if (!s.connected) {\n                s.connected = true;\n                this.makeConnected(s);\n            }\n        }\n    }\n}\n\nlet states1 = \"q0, q1\";\nlet startState1 = \"q0\";\nlet inputAlphabet1 = \"a, b\";\nlet pushdownAlphabet1 = \"A, Z\";\nlet transitions1 = \"(q0, a, Z) -> (q0, AZ); (q0, a, A) -> (q0, AA); (q0, b, A) -> (q1, eps); (q1, b, A) -> (q1, eps); (q1, eps, Z) -> (q1, eps)\"\nlet startStack1 = \"Z\";\nlet accepting1 = \"q1\";\n\nlet astring1 = \"aaabbb\"; // Z\nlet astring2 = \"aaaabbbb\"; // Z\nlet astring3 = \"abbb\"; // AZAZ\nlet astring4 = \"bbbbb\"; // AAAAA\nlet astring5 = \"bbb\"; // AZAZAZZZZ\n\nlet rstring1 = \"aabbba\"; // A, Z, AAZ\nlet rstring2 = \"\"; // anything: A, Z, AA, AAZZ\nlet rstring3 = \"ab\" // Z\nlet rstring4 = \"a\" // Z, A\nlet rstring5 = \"aaabbb\"; // AA, A\n/*\nlet Z_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"Z\", accepting1);\nlet A_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"A\", accepting1);\nlet AA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AA\", accepting1);\nlet AAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAZ\", accepting1);\nlet AZAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZ\", accepting1);\nlet AAAAA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAAAA\", accepting1);\nlet AZAZAZZZZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZAZZZZ\", accepting1);\n*/\n\n/* TESTS: change return statement of checkInputString from return path; to return true; to test again\n// Accept\nif (Z_PDA.checkInputString(\"aaabbb\")) console.log(\"test1: correct output - passed\");\nelse console.log(\"test1: failed\");\n\nif (Z_PDA.checkInputString(astring2)) console.log(\"test2: correct output - passed\")\nelse console.log(\"test2: failed\");\n\n//Wrong test here\nif (AZAZ_PDA.checkInputString(\"abbb\")) console.log(\"test3: correct output - passed\");\nelse console.log(\"test3: failed\"); \n\nif (AAAAA_PDA.checkInputString(\"bbbbb\")) console.log(\"test4: correct output - passed\");\nelse console.log(\"test4: failed\");\n\nif (AZAZAZZZZ_PDA.checkInputString(\"bbb\")) console.log(\"test5: correct output - passed\");\nelse console.log(\"test5: failed\"); \n\nif (Z_PDA.checkInputString(\"ab\")) console.log(\"test13: correct output - passed\");\nelse console.log(\"test13: failed\");\n\nif (A_PDA.checkInputString(\"aaabbbb\")) console.log(\"test16: correct output - passed\");\nelse console.log(\"test16: failed\");\n\n// Reject\nif (!A_PDA.checkInputString(\"aabbba\")) console.log(\"test6: correct output - rejected\");\nelse console.log(\"test6: failed\");\n\nif (!Z_PDA.checkInputString(\"aabbba\")) console.log(\"test7: correct output - rejected\");\nelse console.log(\"test7: failed\");\n\nif (!AAZ_PDA.checkInputString(\"aabbba\")) console.log(\"test8: correct output - rejected\");\nelse console.log(\"test8: failed\");\n\nif (!A_PDA.checkInputString(\"\")) console.log(\"test9: correct output - rejected\");\nelse console.log(\"test9: failed\");\n\nif (!Z_PDA.checkInputString(\"\")) console.log(\"test10: correct output - rejected\");\nelse console.log(\"test10: failed\");\n\nif (!AAZ_PDA.checkInputString(\"\")) console.log(\"test11: correct output - rejected\");\nelse console.log(\"test11: failed\");\n\nif (!AAAAA_PDA.checkInputString(\"\")) console.log(\"test12: correct output - rejected\");\nelse console.log(\"test12: failed\");\n\nif (!Z_PDA.checkInputString(\"a\")) console.log(\"test14: correct output - rejected\");\nelse console.log(\"test14: failed\");\n\nif (!A_PDA.checkInputString(\"a\")) console.log(\"test15: correct output - rejected\");\nelse console.log(\"test15: failed\");\n\nif (!AA_PDA.checkInputString(\"aaabbbb\")) console.log(\"test17: correct output - rejected\");\nelse console.log(\"test17: failed\");\n*/\n\n// Palindrome PDA\nlet states2 = \"s, f\";\nlet transitions2 = \"(s, a, eps) -> (s, A); (s, b, eps) -> (s, B); (s, c, eps) -> (f, eps); (f, a, A) -> (f, eps); (f, b, B) -> (f, eps)\";\nlet startstate2 = \"s\";\nlet initialStack2 = \"\";\nlet inputAlphabet2 = \"a, b, c\";\nlet pushdownAlphabet2 = \"A, B\";\nlet accepting2 = \"f\";\n\n//let testPDA2 = new PDAModel(states2, startstate2, inputAlphabet2, pushdownAlphabet2, transitions2, initialStack2, accepting2);\n\n//console.log(testPDA2.checkInputString(\"aaabbb\"));\n\n//let simplePDA = new PDAModel(\"q0\", \"q0\", \"a,b\", \"A\", \"(q0, a, A) -> (q0, eps); (q0, b, eps) -> (q0, A)\", \"A\", \"q0\");\n//console.log(simplePDA.checkInputString(\"aba\"));"],"mappings":"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"},"metadata":{},"sourceType":"module"}