{"ast":null,"code":"import { parseAlphabet, parseTransition } from \"./DFAModel\";\nexport class Pair {\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n  }\n\n  equalTo(other) {\n    if (this.left === other.left && this.right === other.right) return true;\n    return false;\n  }\n\n}\nexport class NFAState {\n  constructor(name) {\n    this.name = name;\n    this.accepting = false;\n    this.connected = false;\n    this.conn = [];\n    this.transitions = [];\n    this.destOf = [];\n  }\n\n  addTrans(symbol, dest) {\n    this.transitions.push(new Pair(symbol, dest));\n  }\n\n  getAllTrans() {\n    return this.transitions;\n  } // return an array of only epsilon transitions\n\n\n  getEpsilonTrans() {\n    let ret_list = [];\n\n    for (let i in this.transitions) {\n      let ts = this.transitions[i];\n\n      if (ts.left === \"eps\") {\n        ret_list.push(ts);\n      }\n    }\n\n    return ret_list;\n  } // return an array of only non-epsilon transitions\n\n\n  getSymbolTrans(sym) {\n    let ret_list = [];\n\n    for (let i in this.transitions) {\n      let ts = this.transitions[i];\n\n      if (ts.left === sym) {\n        ret_list.push(ts);\n      }\n    }\n\n    return ret_list;\n  }\n\n  addDestOf(state, symbol) {\n    let newPair = new Pair(state, symbol);\n    this.destOf.push(newPair);\n  }\n\n  getSym(src) {\n    let syms = [];\n\n    for (let i in this.destOf) {\n      let p = this.destOf[i];\n\n      if (p.left === src) {\n        syms.push(p.right);\n      }\n    }\n\n    return syms;\n  }\n\n}\nexport class NFAModel {\n  constructor(initial, accepting, all_states, alphabet, transitions) {\n    console.log(\"NFA Model:\");\n    this.all = parseNFAStates(all_states);\n    this.initial = null;\n    this.accepting = [];\n    this.alphabet = parseAlphabet(alphabet);\n    this.transitions = parseTransition(transitions);\n    this.current = new Set();\n    this.syms = null;\n    this.states = null;\n    this.error = null;\n    this.setPath = [];\n    this.input = null;\n    this.acceptance_result = null;\n    console.log(\"initial: \", initial);\n    console.log(\"accepting: \", accepting);\n    console.log(\"states: \", all_states);\n    console.log(\"alphabet: \", alphabet);\n    console.log(\"transitions: \", transitions); // check components and alert if error\n\n    if (!this.checkAlphabet()) {\n      window.alert(this.error);\n    } else if (!this.checkStates()) {\n      window.alert(this.error);\n    } else if (!this.checkInitial(initial)) {\n      window.alert(this.error);\n    } else if (!this.checkAccepting(accepting)) {\n      window.alert(this.error);\n    } else if (!this.checkTransitions()) {\n      window.alert(this.error);\n    } else {\n      // make Connected for all and check\n      this.makeConnected(this.initial);\n\n      for (let i in this.all) {\n        let s = this.all[i];\n\n        if (!s.connected) {\n          console.log(\"State \" + s.name + \" is not reachable.\");\n        }\n      }\n    }\n  } // once checkInputString has run, determine whether or not to accept input\n\n\n  acceptString() {\n    let ret_path = []; //console.log(this.setPath);\n\n    console.log(this.backwardPath);\n\n    for (let a of this.current) {\n      if (a.accepting) {\n        // create acceptance visualization and add it to end of path\n        let accept_state = new NFAState(\"üôÇ\");\n        let acceptance = new Pair(\"‚úîÔ∏è\", accept_state);\n        ret_path.push(acceptance);\n        this.acceptance_result = true;\n        this.backtrack(a);\n        console.log(\"this is the path: \" + this.backwardPath);\n        return ret_path;\n      }\n    } // if not accepting, create fail visualization and add it to end of path\n\n\n    let fail_state = new NFAState(\"üôÅ\");\n    let failure = new Pair(\"‚ùå\", fail_state);\n    ret_path.push(failure);\n    this.acceptance_result = false;\n    return ret_path;\n  } // given an input string, simulate it in the NFA model\n\n\n  checkInputString(input) {\n    // create Set to represent next states and initialize current Set to initial state\n    let next = new Set();\n    this.current = new Set().add(this.initial);\n    this.input = input; // add all epsilon transitons from initial state\n\n    let eps_trans = this.initial.getEpsilonTrans();\n\n    if (eps_trans.length !== 0) {\n      this.setPath.push(this.current);\n\n      for (let trans of eps_trans) {\n        next.add(trans.right);\n      }\n\n      for (let a of next) {\n        let next_eps = a.getEpsilonTrans();\n\n        if (next_eps.length !== 0) {\n          for (let trans of next_eps) {\n            next.add(trans.right);\n          }\n        }\n      }\n\n      next.add(this.initial);\n      this.current = next;\n      this.setPath.push(this.current);\n    } // loop through input\n\n\n    while (input.length > 0) {\n      let str = input.substring(0, 1);\n      input = input.substring(1);\n      let next = new Set();\n      let passing = new Set();\n\n      for (let a of this.current) {\n        let sym_trans = a.getSymbolTrans(str);\n        let eps_trans = a.getEpsilonTrans();\n\n        if (sym_trans.length !== 0) {\n          for (let trans of sym_trans) {\n            next.add(trans.right);\n            passing.add(a);\n          }\n        }\n\n        if (eps_trans.length !== 0) {\n          passing.add(a);\n        }\n      } // if there are no possible next states for the input, the input is rejected\n\n\n      if (next.size === 0 && input.length !== 0) {\n        console.log(\"no possible next states\");\n        let ret_path = [new Pair(\"\", this.initial)];\n        let fail_state = new NFAState(\"üôÅ\");\n        let failure = new Pair(\"‚ùå\", fail_state);\n        ret_path.push(failure);\n        this.acceptance_result = false;\n        return ret_path;\n      }\n\n      for (let b of next) {\n        let eps_trans = b.getEpsilonTrans();\n\n        if (eps_trans !== 0) {\n          for (let trans of eps_trans) {\n            next.add(trans.right);\n            passing.add(b);\n          }\n        }\n      }\n\n      for (let stt of this.current) {\n        if (!passing.has(stt)) {\n          this.current.delete(stt);\n        }\n      }\n\n      this.setPath.push(this.current);\n      this.current = next;\n    }\n\n    this.setPath.push(this.current);\n    return this.acceptString();\n  } // Checks alphabet for repeated symbols or being empty\n\n\n  checkAlphabet() {\n    if (this.alphabet.length === 0) {\n      this.error = \"Empty alphabet\";\n      return false;\n    }\n\n    let symbols = new Set();\n    symbols.add(\"eps\");\n\n    for (let i in this.alphabet) {\n      let s = this.alphabet[i];\n\n      if (symbols.has(s)) {\n        this.error = \"Duplicate in alphabet: \" + s;\n        return false;\n      }\n\n      symbols.add(s);\n    }\n\n    this.syms = symbols;\n    return true;\n  } // Checks states for repeats or conflicts with alphabet\n  // Creates a Map of state names to States (this.states)\n\n\n  checkStates() {\n    if (this.all.length === 0) {\n      this.error = \"Empty States\";\n      return false;\n    }\n\n    let states = new Map();\n\n    for (let i in this.all) {\n      let s = this.all[i];\n\n      if (states.has(s.name) || this.syms.has(s.name)) {\n        this.error = \"Conflicting state name: \" + s.name;\n        return false;\n      }\n\n      states.set(s.name, s);\n    }\n\n    this.states = states;\n    return true;\n  } // Checks that initial state is a valid state and assigns this.initial to the State\n\n\n  checkInitial(initial) {\n    if (this.states.has(initial)) {\n      this.initial = this.states.get(initial);\n      this.initial.connected = true;\n      return true;\n    }\n\n    this.error = \"Invalid initial state\";\n    return false;\n  } // Checks that accepting states are present and valid\n  // Creates an array of the appropriate accepting States in this.accepting\n\n\n  checkAccepting(accepting) {\n    let acc_array = parseAlphabet(accepting);\n\n    if (acc_array.length === 0) {\n      this.error = \"Empty accepting states\";\n      return false;\n    }\n\n    for (let i in acc_array) {\n      let acc_name = acc_array[i];\n\n      if (!this.states.has(acc_name)) {\n        this.error = \"Accepting state \" + acc_name + \" does not exist\";\n        return false;\n      }\n\n      this.states.get(acc_name).accepting = true;\n      this.accepting.push(this.states.get(acc_name));\n    }\n\n    return true;\n  } // Checks that transitions are valid symbols/states/states, and are not duplicates of prior transitions\n  // Sets up connections to check all states are connected\n\n\n  checkTransitions() {\n    if (this.transitions.length === 0) {\n      this.error = \"Empty transitions\";\n      return false;\n    }\n\n    for (let i in this.transitions) {\n      let t = this.transitions[i];\n\n      if (!this.syms.has(t.symbol)) {\n        this.error = \"Invalid symbol in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n        return false;\n      }\n\n      if (!this.states.has(t.source)) {\n        this.error = \"Invalid source in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n        return false;\n      }\n\n      if (!this.states.has(t.dest)) {\n        this.error = \"Invalid destination in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n        return false;\n      }\n\n      t.source = this.states.get(t.source);\n      t.dest = this.states.get(t.dest);\n      let src_state = t.source;\n\n      for (let j in src_state.getAllTrans()) {\n        let ts = src_state.getAllTrans()[j];\n\n        if (ts.left === t.symbol && ts.right === t.dest) {\n          this.error = \"Transition (\" + t.symbol + \", \" + t.source.name + \", \" + t.dest.name + \") already exists\";\n          return false;\n        }\n      }\n\n      src_state.addTrans(t.symbol, t.dest);\n      t.dest.addDestOf(src_state, t.symbol); // Add the dest State to source.conn for connection check\n\n      if (!t.source.conn.includes(t.dest)) {\n        t.source.conn.push(t.dest);\n      }\n    }\n\n    return true;\n  } // uses conn lists in states to set connected to bool value\n\n\n  makeConnected(start) {\n    for (let i in start.conn) {\n      let s = start.conn[i];\n\n      if (!s.connected) {\n        s.connected = true;\n        this.makeConnected(s);\n      }\n    }\n  } // start at back of array and go back picking options from the previous set that have transitions that go to the current state chosen\n\n\n  backtrack(accState) {\n    let backwardPath = [];\n    let inp = this.input.split(\"\");\n    console.log(inp.length);\n    let currState = accState;\n    let revPath = this.setPath.reverse();\n\n    for (let i in revPath.length - 1) {\n      let chr = inp[0];\n      let currSet = revPath[i];\n      let x = 0;\n\n      for (let src of revPath[i + 1]) {\n        if (currState.getSym(src).has(chr)) {\n          let currPair = new Pair(currState, chr);\n          backwardPath.push(currPair);\n          currState = src;\n          inp.pop();\n          break;\n        } else if (currState.getSym(src).has(\"eps\")) {\n          let currPair = new Pair(currState, \"Œµ\");\n          backwardPath.push(currPair);\n          currState = src;\n          break;\n        }\n      } // currState holds the starting state\n\n    }\n  }\n\n} // parse states string input into NFAState array\n\nexport function parseNFAStates(input) {\n  input = input.replaceAll(\" \", \"\");\n  if (input.length === 0) return [];\n  let input_array = input.split(',');\n  let states_array = [];\n\n  for (let i in input_array) {\n    let str_state = input_array[i];\n    states_array[i] = new NFAState(str_state);\n  }\n\n  return states_array;\n}","map":{"version":3,"names":["parseAlphabet","parseTransition","Pair","constructor","left","right","equalTo","other","NFAState","name","accepting","connected","conn","transitions","destOf","addTrans","symbol","dest","push","getAllTrans","getEpsilonTrans","ret_list","i","ts","getSymbolTrans","sym","addDestOf","state","newPair","getSym","src","syms","p","NFAModel","initial","all_states","alphabet","console","log","all","parseNFAStates","current","Set","states","error","setPath","input","acceptance_result","checkAlphabet","window","alert","checkStates","checkInitial","checkAccepting","checkTransitions","makeConnected","s","acceptString","ret_path","backwardPath","a","accept_state","acceptance","backtrack","fail_state","failure","checkInputString","next","add","eps_trans","length","trans","next_eps","str","substring","passing","sym_trans","size","b","stt","has","delete","symbols","Map","set","get","acc_array","acc_name","t","source","src_state","j","includes","start","accState","inp","split","currState","revPath","reverse","chr","currSet","x","currPair","pop","replaceAll","input_array","states_array","str_state"],"sources":["/Users/simonlow/Documents/ModelsOfCompSimulator-2/client/src/components/input/NFAModel.js"],"sourcesContent":["import { parseAlphabet, parseTransition } from \"./DFAModel\";\n\nexport class Pair {\n    constructor(left, right) {\n        this.left = left;\n        this.right = right;\n    }\n\n    equalTo(other) {\n        if ((this.left === other.left) && (this.right === other.right)) return true;\n        return false;\n    }\n}\n\nexport class NFAState {\n    constructor(name) {\n        this.name = name;\n        this.accepting = false;\n        this.connected = false;\n        this.conn = [];\n        this.transitions = [];\n        this.destOf = [];\n    }\n\n    addTrans(symbol, dest) {\n        this.transitions.push(new Pair(symbol, dest));\n    }\n\n    getAllTrans() {\n        return this.transitions;\n    }\n\n    // return an array of only epsilon transitions\n    getEpsilonTrans() {\n        let ret_list = [];\n        for (let i in this.transitions) {\n            let ts = this.transitions[i];\n            if (ts.left === \"eps\") {\n                ret_list.push(ts);\n            }\n        }\n        return ret_list;\n    }\n\n    // return an array of only non-epsilon transitions\n    getSymbolTrans(sym) {\n        let ret_list = [];\n        for (let i in this.transitions) {\n            let ts = this.transitions[i];\n            if (ts.left === sym) {\n                ret_list.push(ts);\n            }\n        }\n        return ret_list;\n    }\n\n    addDestOf(state, symbol) {\n        let newPair = new Pair(state, symbol);\n        this.destOf.push(newPair);\n    }\n\n    getSym(src) {\n        let syms = [];\n        for (let i in this.destOf) {\n            let p = this.destOf[i];\n            if (p.left === src) {\n                syms.push(p.right);\n            }\n        }\n        return syms; \n    }\n}\n\nexport class NFAModel {\n    constructor(initial, accepting, all_states, alphabet, transitions) {\n        console.log(\"NFA Model:\");\n        this.all = parseNFAStates(all_states);\n        this.initial = null;\n        this.accepting = [];\n        this.alphabet = parseAlphabet(alphabet);\n        this.transitions = parseTransition(transitions);\n        this.current = new Set();\n        this.syms = null;\n        this.states = null;\n        this.error = null;\n        this.setPath = [];\n        this.input = null;\n        this.acceptance_result = null;\n\n        console.log(\"initial: \", initial);\n        console.log(\"accepting: \", accepting);\n        console.log(\"states: \", all_states);\n        console.log(\"alphabet: \", alphabet);\n        console.log(\"transitions: \", transitions);\n\n        // check components and alert if error\n        if (!this.checkAlphabet()) {\n            window.alert(this.error);\n        } else if (!this.checkStates()) {\n            window.alert(this.error);\n        } else if (!this.checkInitial(initial)) {\n            window.alert(this.error);\n        } else if (!this.checkAccepting(accepting)) {\n            window.alert(this.error);\n        } else if (!this.checkTransitions()) {\n            window.alert(this.error);\n        } else {\n            // make Connected for all and check\n            this.makeConnected(this.initial);\n            for (let i in this.all) {\n                let s = this.all[i];\n                if (!s.connected) {\n                    console.log(\"State \" + s.name + \" is not reachable.\");\n                }\n            }\n        }\n    }\n\n    // once checkInputString has run, determine whether or not to accept input\n    acceptString() {\n        let ret_path = [];\n        //console.log(this.setPath);\n        console.log(this.backwardPath)\n        for (let a of this.current) {\n            if (a.accepting) {\n                // create acceptance visualization and add it to end of path\n                let accept_state = new NFAState(\"üôÇ\");\n                let acceptance = new Pair(\"‚úîÔ∏è\", accept_state);\n                ret_path.push(acceptance);\n                this.acceptance_result = true;\n                this.backtrack(a);\n                console.log(\"this is the path: \" + this.backwardPath);\n                return ret_path;\n            }\n        }\n        // if not accepting, create fail visualization and add it to end of path\n        let fail_state = new NFAState(\"üôÅ\");\n        let failure = new Pair(\"‚ùå\", fail_state);\n        ret_path.push(failure);\n        this.acceptance_result = false;\n        return ret_path;\n    }\n\n    // given an input string, simulate it in the NFA model\n    checkInputString(input) {\n        // create Set to represent next states and initialize current Set to initial state\n        let next = new Set();\n        this.current = new Set().add(this.initial);\n        this.input = input;\n\n        // add all epsilon transitons from initial state\n        let eps_trans = this.initial.getEpsilonTrans();\n        if (eps_trans.length !== 0) {\n            this.setPath.push(this.current);\n            for (let trans of eps_trans) {\n                next.add(trans.right);\n            }\n            for (let a of next) {\n                let next_eps = a.getEpsilonTrans();\n                if (next_eps.length !== 0) {\n                    for (let trans of next_eps) {\n                        next.add(trans.right);\n                    } \n                }\n            }\n            next.add(this.initial);\n            this.current = next;\n            this.setPath.push(this.current);\n        }\n\n        // loop through input\n        while (input.length > 0) {\n            let str = input.substring(0, 1);\n            input = input.substring(1);\n            let next = new Set();\n\n            let passing = new Set();\n\n            for (let a of this.current) {\n                let sym_trans = a.getSymbolTrans(str);\n                let eps_trans = a.getEpsilonTrans();\n                if (sym_trans.length !== 0) {\n                    for (let trans of sym_trans) {\n                        next.add(trans.right);\n                        passing.add(a);\n                    }\n                }\n                if (eps_trans.length !== 0) {\n                    passing.add(a);\n                }\n            }\n\n            // if there are no possible next states for the input, the input is rejected\n            if (next.size === 0 && input.length !== 0) {\n                console.log(\"no possible next states\");\n                let ret_path = [new Pair(\"\", this.initial)];\n                let fail_state = new NFAState(\"üôÅ\");\n                let failure = new Pair(\"‚ùå\", fail_state);\n                ret_path.push(failure);\n                this.acceptance_result = false;\n                return ret_path;\n            }\n\n            for (let b of next) {\n                let eps_trans = b.getEpsilonTrans();\n                if (eps_trans !== 0) {\n                    for (let trans of eps_trans) {\n                        next.add(trans.right);\n                        passing.add(b);\n                    }\n                }\n            } \n            \n            for (let stt of this.current) {\n                if (!passing.has(stt)) {\n                    this.current.delete(stt);\n                }\n            }\n\n            this.setPath.push(this.current);\n            this.current = next;\n        }\n        this.setPath.push(this.current);\n        return this.acceptString();\n    }\n\n    // Checks alphabet for repeated symbols or being empty\n    checkAlphabet() {\n        if (this.alphabet.length === 0) {\n            this.error = \"Empty alphabet\";\n            return false;\n        }\n\n        let symbols = new Set();\n        symbols.add(\"eps\");\n        for (let i in this.alphabet) {\n            let s = this.alphabet[i];\n            if (symbols.has(s)) {\n                this.error = \"Duplicate in alphabet: \" + s;\n                return false;\n            }\n            symbols.add(s);\n        }\n\n        this.syms = symbols;\n        return true;\n    }\n\n    // Checks states for repeats or conflicts with alphabet\n    // Creates a Map of state names to States (this.states)\n    checkStates() {\n        if (this.all.length === 0) {\n            this.error = \"Empty States\";\n            return false;\n        }\n\n        let states = new Map();\n        for (let i in this.all) {\n            let s = this.all[i];\n            if (states.has(s.name) || this.syms.has(s.name)) {\n                this.error = \"Conflicting state name: \" + s.name;\n                return false;\n            }\n            states.set(s.name, s);\n        }\n\n        this.states = states;\n        return true;\n    }\n\n    // Checks that initial state is a valid state and assigns this.initial to the State\n    checkInitial(initial) {\n        if (this.states.has(initial)) {\n            this.initial = this.states.get(initial);\n            this.initial.connected = true;\n            return true;\n        }\n        this.error = \"Invalid initial state\";\n        return false;\n    }\n\n    // Checks that accepting states are present and valid\n    // Creates an array of the appropriate accepting States in this.accepting\n    checkAccepting(accepting) {\n        let acc_array = parseAlphabet(accepting);\n        if (acc_array.length === 0) {\n            this.error = \"Empty accepting states\";\n            return false;\n        }\n\n        for (let i in acc_array) {\n            let acc_name = acc_array[i];\n            if (!this.states.has(acc_name)) {\n                this.error = \"Accepting state \" + acc_name + \" does not exist\";\n                return false;\n            }\n            this.states.get(acc_name).accepting = true;\n            this.accepting.push(this.states.get(acc_name));\n        }\n        return true;\n    }\n\n    // Checks that transitions are valid symbols/states/states, and are not duplicates of prior transitions\n    // Sets up connections to check all states are connected\n    checkTransitions() {\n        if (this.transitions.length === 0) {\n            this.error = \"Empty transitions\";\n            return false;\n        }\n\n        for (let i in this.transitions) {\n            let t = this.transitions[i];\n\n            if (!this.syms.has(t.symbol)) {\n                this.error = \"Invalid symbol in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n                return false;\n            }\n            if (!this.states.has(t.source)) {\n                this.error = \"Invalid source in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n                return false;\n            }\n            if (!this.states.has(t.dest)) {\n                this.error = \"Invalid destination in transition: (\" + t.symbol + \", \" + t.source + \", \" + t.dest + \")\";\n                return false;\n            }\n\n            t.source = this.states.get(t.source);\n            t.dest = this.states.get(t.dest);\n\n            let src_state = t.source;\n            for (let j in src_state.getAllTrans()) {\n                let ts = src_state.getAllTrans()[j];\n                if ((ts.left === t.symbol) && (ts.right === t.dest)) {\n                    this.error = \"Transition (\" + t.symbol + \", \" + t.source.name + \", \" + t.dest.name + \") already exists\";\n                    return false;\n                }\n            }\n            src_state.addTrans(t.symbol, t.dest);\n            t.dest.addDestOf(src_state, t.symbol);\n\n            // Add the dest State to source.conn for connection check\n            if (!t.source.conn.includes(t.dest)) {\n                t.source.conn.push(t.dest);\n            }\n        }\n        return true;\n    }\n\n    // uses conn lists in states to set connected to bool value\n    makeConnected(start) {\n        for (let i in start.conn) {\n            let s = start.conn[i];\n            if (!s.connected) {\n                s.connected = true;\n                this.makeConnected(s);\n            }\n        }\n    }\n\n    // start at back of array and go back picking options from the previous set that have transitions that go to the current state chosen\n    backtrack(accState) {\n        let backwardPath = [];\n        let inp = this.input.split(\"\");\n        console.log(inp.length);\n        let currState = accState;\n        let revPath = this.setPath.reverse();\n        for (let i in revPath.length-1) {\n            let chr = inp[0];\n            let currSet = revPath[i];\n            let x = 0;\n            for (let src of revPath[i+1]) {\n                if (currState.getSym(src).has(chr)) {\n                    let currPair = new Pair(currState, chr);\n                    backwardPath.push(currPair);\n                    currState = src;\n                    inp.pop();\n                    break;\n                }\n                else if (currState.getSym(src).has(\"eps\")) {\n                    let currPair = new Pair(currState, \"Œµ\");\n                    backwardPath.push(currPair);\n                    currState = src;\n                    break;\n                }\n            }\n            // currState holds the starting state\n        }\n        \n    }\n}\n\n// parse states string input into NFAState array\nexport function parseNFAStates(input) {\n    input = input.replaceAll(\" \", \"\");\n    if (input.length === 0) return [];\n    let input_array = input.split(',');\n    let states_array = [];\n    for (let i in input_array) {\n        let str_state = input_array[i];\n        states_array[i] = new NFAState(str_state);\n    }\n    return states_array;\n}\n"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,eAAxB,QAA+C,YAA/C;AAEA,OAAO,MAAMC,IAAN,CAAW;EACdC,WAAW,CAACC,IAAD,EAAOC,KAAP,EAAc;IACrB,KAAKD,IAAL,GAAYA,IAAZ;IACA,KAAKC,KAAL,GAAaA,KAAb;EACH;;EAEDC,OAAO,CAACC,KAAD,EAAQ;IACX,IAAK,KAAKH,IAAL,KAAcG,KAAK,CAACH,IAArB,IAA+B,KAAKC,KAAL,KAAeE,KAAK,CAACF,KAAxD,EAAgE,OAAO,IAAP;IAChE,OAAO,KAAP;EACH;;AATa;AAYlB,OAAO,MAAMG,QAAN,CAAe;EAClBL,WAAW,CAACM,IAAD,EAAO;IACd,KAAKA,IAAL,GAAYA,IAAZ;IACA,KAAKC,SAAL,GAAiB,KAAjB;IACA,KAAKC,SAAL,GAAiB,KAAjB;IACA,KAAKC,IAAL,GAAY,EAAZ;IACA,KAAKC,WAAL,GAAmB,EAAnB;IACA,KAAKC,MAAL,GAAc,EAAd;EACH;;EAEDC,QAAQ,CAACC,MAAD,EAASC,IAAT,EAAe;IACnB,KAAKJ,WAAL,CAAiBK,IAAjB,CAAsB,IAAIhB,IAAJ,CAASc,MAAT,EAAiBC,IAAjB,CAAtB;EACH;;EAEDE,WAAW,GAAG;IACV,OAAO,KAAKN,WAAZ;EACH,CAhBiB,CAkBlB;;;EACAO,eAAe,GAAG;IACd,IAAIC,QAAQ,GAAG,EAAf;;IACA,KAAK,IAAIC,CAAT,IAAc,KAAKT,WAAnB,EAAgC;MAC5B,IAAIU,EAAE,GAAG,KAAKV,WAAL,CAAiBS,CAAjB,CAAT;;MACA,IAAIC,EAAE,CAACnB,IAAH,KAAY,KAAhB,EAAuB;QACnBiB,QAAQ,CAACH,IAAT,CAAcK,EAAd;MACH;IACJ;;IACD,OAAOF,QAAP;EACH,CA5BiB,CA8BlB;;;EACAG,cAAc,CAACC,GAAD,EAAM;IAChB,IAAIJ,QAAQ,GAAG,EAAf;;IACA,KAAK,IAAIC,CAAT,IAAc,KAAKT,WAAnB,EAAgC;MAC5B,IAAIU,EAAE,GAAG,KAAKV,WAAL,CAAiBS,CAAjB,CAAT;;MACA,IAAIC,EAAE,CAACnB,IAAH,KAAYqB,GAAhB,EAAqB;QACjBJ,QAAQ,CAACH,IAAT,CAAcK,EAAd;MACH;IACJ;;IACD,OAAOF,QAAP;EACH;;EAEDK,SAAS,CAACC,KAAD,EAAQX,MAAR,EAAgB;IACrB,IAAIY,OAAO,GAAG,IAAI1B,IAAJ,CAASyB,KAAT,EAAgBX,MAAhB,CAAd;IACA,KAAKF,MAAL,CAAYI,IAAZ,CAAiBU,OAAjB;EACH;;EAEDC,MAAM,CAACC,GAAD,EAAM;IACR,IAAIC,IAAI,GAAG,EAAX;;IACA,KAAK,IAAIT,CAAT,IAAc,KAAKR,MAAnB,EAA2B;MACvB,IAAIkB,CAAC,GAAG,KAAKlB,MAAL,CAAYQ,CAAZ,CAAR;;MACA,IAAIU,CAAC,CAAC5B,IAAF,KAAW0B,GAAf,EAAoB;QAChBC,IAAI,CAACb,IAAL,CAAUc,CAAC,CAAC3B,KAAZ;MACH;IACJ;;IACD,OAAO0B,IAAP;EACH;;AAxDiB;AA2DtB,OAAO,MAAME,QAAN,CAAe;EAClB9B,WAAW,CAAC+B,OAAD,EAAUxB,SAAV,EAAqByB,UAArB,EAAiCC,QAAjC,EAA2CvB,WAA3C,EAAwD;IAC/DwB,OAAO,CAACC,GAAR,CAAY,YAAZ;IACA,KAAKC,GAAL,GAAWC,cAAc,CAACL,UAAD,CAAzB;IACA,KAAKD,OAAL,GAAe,IAAf;IACA,KAAKxB,SAAL,GAAiB,EAAjB;IACA,KAAK0B,QAAL,GAAgBpC,aAAa,CAACoC,QAAD,CAA7B;IACA,KAAKvB,WAAL,GAAmBZ,eAAe,CAACY,WAAD,CAAlC;IACA,KAAK4B,OAAL,GAAe,IAAIC,GAAJ,EAAf;IACA,KAAKX,IAAL,GAAY,IAAZ;IACA,KAAKY,MAAL,GAAc,IAAd;IACA,KAAKC,KAAL,GAAa,IAAb;IACA,KAAKC,OAAL,GAAe,EAAf;IACA,KAAKC,KAAL,GAAa,IAAb;IACA,KAAKC,iBAAL,GAAyB,IAAzB;IAEAV,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBJ,OAAzB;IACAG,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2B5B,SAA3B;IACA2B,OAAO,CAACC,GAAR,CAAY,UAAZ,EAAwBH,UAAxB;IACAE,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BF,QAA1B;IACAC,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6BzB,WAA7B,EAnB+D,CAqB/D;;IACA,IAAI,CAAC,KAAKmC,aAAL,EAAL,EAA2B;MACvBC,MAAM,CAACC,KAAP,CAAa,KAAKN,KAAlB;IACH,CAFD,MAEO,IAAI,CAAC,KAAKO,WAAL,EAAL,EAAyB;MAC5BF,MAAM,CAACC,KAAP,CAAa,KAAKN,KAAlB;IACH,CAFM,MAEA,IAAI,CAAC,KAAKQ,YAAL,CAAkBlB,OAAlB,CAAL,EAAiC;MACpCe,MAAM,CAACC,KAAP,CAAa,KAAKN,KAAlB;IACH,CAFM,MAEA,IAAI,CAAC,KAAKS,cAAL,CAAoB3C,SAApB,CAAL,EAAqC;MACxCuC,MAAM,CAACC,KAAP,CAAa,KAAKN,KAAlB;IACH,CAFM,MAEA,IAAI,CAAC,KAAKU,gBAAL,EAAL,EAA8B;MACjCL,MAAM,CAACC,KAAP,CAAa,KAAKN,KAAlB;IACH,CAFM,MAEA;MACH;MACA,KAAKW,aAAL,CAAmB,KAAKrB,OAAxB;;MACA,KAAK,IAAIZ,CAAT,IAAc,KAAKiB,GAAnB,EAAwB;QACpB,IAAIiB,CAAC,GAAG,KAAKjB,GAAL,CAASjB,CAAT,CAAR;;QACA,IAAI,CAACkC,CAAC,CAAC7C,SAAP,EAAkB;UACd0B,OAAO,CAACC,GAAR,CAAY,WAAWkB,CAAC,CAAC/C,IAAb,GAAoB,oBAAhC;QACH;MACJ;IACJ;EACJ,CA3CiB,CA6ClB;;;EACAgD,YAAY,GAAG;IACX,IAAIC,QAAQ,GAAG,EAAf,CADW,CAEX;;IACArB,OAAO,CAACC,GAAR,CAAY,KAAKqB,YAAjB;;IACA,KAAK,IAAIC,CAAT,IAAc,KAAKnB,OAAnB,EAA4B;MACxB,IAAImB,CAAC,CAAClD,SAAN,EAAiB;QACb;QACA,IAAImD,YAAY,GAAG,IAAIrD,QAAJ,CAAa,IAAb,CAAnB;QACA,IAAIsD,UAAU,GAAG,IAAI5D,IAAJ,CAAS,IAAT,EAAe2D,YAAf,CAAjB;QACAH,QAAQ,CAACxC,IAAT,CAAc4C,UAAd;QACA,KAAKf,iBAAL,GAAyB,IAAzB;QACA,KAAKgB,SAAL,CAAeH,CAAf;QACAvB,OAAO,CAACC,GAAR,CAAY,uBAAuB,KAAKqB,YAAxC;QACA,OAAOD,QAAP;MACH;IACJ,CAfU,CAgBX;;;IACA,IAAIM,UAAU,GAAG,IAAIxD,QAAJ,CAAa,IAAb,CAAjB;IACA,IAAIyD,OAAO,GAAG,IAAI/D,IAAJ,CAAS,GAAT,EAAc8D,UAAd,CAAd;IACAN,QAAQ,CAACxC,IAAT,CAAc+C,OAAd;IACA,KAAKlB,iBAAL,GAAyB,KAAzB;IACA,OAAOW,QAAP;EACH,CApEiB,CAsElB;;;EACAQ,gBAAgB,CAACpB,KAAD,EAAQ;IACpB;IACA,IAAIqB,IAAI,GAAG,IAAIzB,GAAJ,EAAX;IACA,KAAKD,OAAL,GAAe,IAAIC,GAAJ,GAAU0B,GAAV,CAAc,KAAKlC,OAAnB,CAAf;IACA,KAAKY,KAAL,GAAaA,KAAb,CAJoB,CAMpB;;IACA,IAAIuB,SAAS,GAAG,KAAKnC,OAAL,CAAad,eAAb,EAAhB;;IACA,IAAIiD,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B;MACxB,KAAKzB,OAAL,CAAa3B,IAAb,CAAkB,KAAKuB,OAAvB;;MACA,KAAK,IAAI8B,KAAT,IAAkBF,SAAlB,EAA6B;QACzBF,IAAI,CAACC,GAAL,CAASG,KAAK,CAAClE,KAAf;MACH;;MACD,KAAK,IAAIuD,CAAT,IAAcO,IAAd,EAAoB;QAChB,IAAIK,QAAQ,GAAGZ,CAAC,CAACxC,eAAF,EAAf;;QACA,IAAIoD,QAAQ,CAACF,MAAT,KAAoB,CAAxB,EAA2B;UACvB,KAAK,IAAIC,KAAT,IAAkBC,QAAlB,EAA4B;YACxBL,IAAI,CAACC,GAAL,CAASG,KAAK,CAAClE,KAAf;UACH;QACJ;MACJ;;MACD8D,IAAI,CAACC,GAAL,CAAS,KAAKlC,OAAd;MACA,KAAKO,OAAL,GAAe0B,IAAf;MACA,KAAKtB,OAAL,CAAa3B,IAAb,CAAkB,KAAKuB,OAAvB;IACH,CAxBmB,CA0BpB;;;IACA,OAAOK,KAAK,CAACwB,MAAN,GAAe,CAAtB,EAAyB;MACrB,IAAIG,GAAG,GAAG3B,KAAK,CAAC4B,SAAN,CAAgB,CAAhB,EAAmB,CAAnB,CAAV;MACA5B,KAAK,GAAGA,KAAK,CAAC4B,SAAN,CAAgB,CAAhB,CAAR;MACA,IAAIP,IAAI,GAAG,IAAIzB,GAAJ,EAAX;MAEA,IAAIiC,OAAO,GAAG,IAAIjC,GAAJ,EAAd;;MAEA,KAAK,IAAIkB,CAAT,IAAc,KAAKnB,OAAnB,EAA4B;QACxB,IAAImC,SAAS,GAAGhB,CAAC,CAACpC,cAAF,CAAiBiD,GAAjB,CAAhB;QACA,IAAIJ,SAAS,GAAGT,CAAC,CAACxC,eAAF,EAAhB;;QACA,IAAIwD,SAAS,CAACN,MAAV,KAAqB,CAAzB,EAA4B;UACxB,KAAK,IAAIC,KAAT,IAAkBK,SAAlB,EAA6B;YACzBT,IAAI,CAACC,GAAL,CAASG,KAAK,CAAClE,KAAf;YACAsE,OAAO,CAACP,GAAR,CAAYR,CAAZ;UACH;QACJ;;QACD,IAAIS,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B;UACxBK,OAAO,CAACP,GAAR,CAAYR,CAAZ;QACH;MACJ,CAnBoB,CAqBrB;;;MACA,IAAIO,IAAI,CAACU,IAAL,KAAc,CAAd,IAAmB/B,KAAK,CAACwB,MAAN,KAAiB,CAAxC,EAA2C;QACvCjC,OAAO,CAACC,GAAR,CAAY,yBAAZ;QACA,IAAIoB,QAAQ,GAAG,CAAC,IAAIxD,IAAJ,CAAS,EAAT,EAAa,KAAKgC,OAAlB,CAAD,CAAf;QACA,IAAI8B,UAAU,GAAG,IAAIxD,QAAJ,CAAa,IAAb,CAAjB;QACA,IAAIyD,OAAO,GAAG,IAAI/D,IAAJ,CAAS,GAAT,EAAc8D,UAAd,CAAd;QACAN,QAAQ,CAACxC,IAAT,CAAc+C,OAAd;QACA,KAAKlB,iBAAL,GAAyB,KAAzB;QACA,OAAOW,QAAP;MACH;;MAED,KAAK,IAAIoB,CAAT,IAAcX,IAAd,EAAoB;QAChB,IAAIE,SAAS,GAAGS,CAAC,CAAC1D,eAAF,EAAhB;;QACA,IAAIiD,SAAS,KAAK,CAAlB,EAAqB;UACjB,KAAK,IAAIE,KAAT,IAAkBF,SAAlB,EAA6B;YACzBF,IAAI,CAACC,GAAL,CAASG,KAAK,CAAClE,KAAf;YACAsE,OAAO,CAACP,GAAR,CAAYU,CAAZ;UACH;QACJ;MACJ;;MAED,KAAK,IAAIC,GAAT,IAAgB,KAAKtC,OAArB,EAA8B;QAC1B,IAAI,CAACkC,OAAO,CAACK,GAAR,CAAYD,GAAZ,CAAL,EAAuB;UACnB,KAAKtC,OAAL,CAAawC,MAAb,CAAoBF,GAApB;QACH;MACJ;;MAED,KAAKlC,OAAL,CAAa3B,IAAb,CAAkB,KAAKuB,OAAvB;MACA,KAAKA,OAAL,GAAe0B,IAAf;IACH;;IACD,KAAKtB,OAAL,CAAa3B,IAAb,CAAkB,KAAKuB,OAAvB;IACA,OAAO,KAAKgB,YAAL,EAAP;EACH,CAvJiB,CAyJlB;;;EACAT,aAAa,GAAG;IACZ,IAAI,KAAKZ,QAAL,CAAckC,MAAd,KAAyB,CAA7B,EAAgC;MAC5B,KAAK1B,KAAL,GAAa,gBAAb;MACA,OAAO,KAAP;IACH;;IAED,IAAIsC,OAAO,GAAG,IAAIxC,GAAJ,EAAd;IACAwC,OAAO,CAACd,GAAR,CAAY,KAAZ;;IACA,KAAK,IAAI9C,CAAT,IAAc,KAAKc,QAAnB,EAA6B;MACzB,IAAIoB,CAAC,GAAG,KAAKpB,QAAL,CAAcd,CAAd,CAAR;;MACA,IAAI4D,OAAO,CAACF,GAAR,CAAYxB,CAAZ,CAAJ,EAAoB;QAChB,KAAKZ,KAAL,GAAa,4BAA4BY,CAAzC;QACA,OAAO,KAAP;MACH;;MACD0B,OAAO,CAACd,GAAR,CAAYZ,CAAZ;IACH;;IAED,KAAKzB,IAAL,GAAYmD,OAAZ;IACA,OAAO,IAAP;EACH,CA7KiB,CA+KlB;EACA;;;EACA/B,WAAW,GAAG;IACV,IAAI,KAAKZ,GAAL,CAAS+B,MAAT,KAAoB,CAAxB,EAA2B;MACvB,KAAK1B,KAAL,GAAa,cAAb;MACA,OAAO,KAAP;IACH;;IAED,IAAID,MAAM,GAAG,IAAIwC,GAAJ,EAAb;;IACA,KAAK,IAAI7D,CAAT,IAAc,KAAKiB,GAAnB,EAAwB;MACpB,IAAIiB,CAAC,GAAG,KAAKjB,GAAL,CAASjB,CAAT,CAAR;;MACA,IAAIqB,MAAM,CAACqC,GAAP,CAAWxB,CAAC,CAAC/C,IAAb,KAAsB,KAAKsB,IAAL,CAAUiD,GAAV,CAAcxB,CAAC,CAAC/C,IAAhB,CAA1B,EAAiD;QAC7C,KAAKmC,KAAL,GAAa,6BAA6BY,CAAC,CAAC/C,IAA5C;QACA,OAAO,KAAP;MACH;;MACDkC,MAAM,CAACyC,GAAP,CAAW5B,CAAC,CAAC/C,IAAb,EAAmB+C,CAAnB;IACH;;IAED,KAAKb,MAAL,GAAcA,MAAd;IACA,OAAO,IAAP;EACH,CAnMiB,CAqMlB;;;EACAS,YAAY,CAAClB,OAAD,EAAU;IAClB,IAAI,KAAKS,MAAL,CAAYqC,GAAZ,CAAgB9C,OAAhB,CAAJ,EAA8B;MAC1B,KAAKA,OAAL,GAAe,KAAKS,MAAL,CAAY0C,GAAZ,CAAgBnD,OAAhB,CAAf;MACA,KAAKA,OAAL,CAAavB,SAAb,GAAyB,IAAzB;MACA,OAAO,IAAP;IACH;;IACD,KAAKiC,KAAL,GAAa,uBAAb;IACA,OAAO,KAAP;EACH,CA9MiB,CAgNlB;EACA;;;EACAS,cAAc,CAAC3C,SAAD,EAAY;IACtB,IAAI4E,SAAS,GAAGtF,aAAa,CAACU,SAAD,CAA7B;;IACA,IAAI4E,SAAS,CAAChB,MAAV,KAAqB,CAAzB,EAA4B;MACxB,KAAK1B,KAAL,GAAa,wBAAb;MACA,OAAO,KAAP;IACH;;IAED,KAAK,IAAItB,CAAT,IAAcgE,SAAd,EAAyB;MACrB,IAAIC,QAAQ,GAAGD,SAAS,CAAChE,CAAD,CAAxB;;MACA,IAAI,CAAC,KAAKqB,MAAL,CAAYqC,GAAZ,CAAgBO,QAAhB,CAAL,EAAgC;QAC5B,KAAK3C,KAAL,GAAa,qBAAqB2C,QAArB,GAAgC,iBAA7C;QACA,OAAO,KAAP;MACH;;MACD,KAAK5C,MAAL,CAAY0C,GAAZ,CAAgBE,QAAhB,EAA0B7E,SAA1B,GAAsC,IAAtC;MACA,KAAKA,SAAL,CAAeQ,IAAf,CAAoB,KAAKyB,MAAL,CAAY0C,GAAZ,CAAgBE,QAAhB,CAApB;IACH;;IACD,OAAO,IAAP;EACH,CAnOiB,CAqOlB;EACA;;;EACAjC,gBAAgB,GAAG;IACf,IAAI,KAAKzC,WAAL,CAAiByD,MAAjB,KAA4B,CAAhC,EAAmC;MAC/B,KAAK1B,KAAL,GAAa,mBAAb;MACA,OAAO,KAAP;IACH;;IAED,KAAK,IAAItB,CAAT,IAAc,KAAKT,WAAnB,EAAgC;MAC5B,IAAI2E,CAAC,GAAG,KAAK3E,WAAL,CAAiBS,CAAjB,CAAR;;MAEA,IAAI,CAAC,KAAKS,IAAL,CAAUiD,GAAV,CAAcQ,CAAC,CAACxE,MAAhB,CAAL,EAA8B;QAC1B,KAAK4B,KAAL,GAAa,oCAAoC4C,CAAC,CAACxE,MAAtC,GAA+C,IAA/C,GAAsDwE,CAAC,CAACC,MAAxD,GAAiE,IAAjE,GAAwED,CAAC,CAACvE,IAA1E,GAAiF,GAA9F;QACA,OAAO,KAAP;MACH;;MACD,IAAI,CAAC,KAAK0B,MAAL,CAAYqC,GAAZ,CAAgBQ,CAAC,CAACC,MAAlB,CAAL,EAAgC;QAC5B,KAAK7C,KAAL,GAAa,oCAAoC4C,CAAC,CAACxE,MAAtC,GAA+C,IAA/C,GAAsDwE,CAAC,CAACC,MAAxD,GAAiE,IAAjE,GAAwED,CAAC,CAACvE,IAA1E,GAAiF,GAA9F;QACA,OAAO,KAAP;MACH;;MACD,IAAI,CAAC,KAAK0B,MAAL,CAAYqC,GAAZ,CAAgBQ,CAAC,CAACvE,IAAlB,CAAL,EAA8B;QAC1B,KAAK2B,KAAL,GAAa,yCAAyC4C,CAAC,CAACxE,MAA3C,GAAoD,IAApD,GAA2DwE,CAAC,CAACC,MAA7D,GAAsE,IAAtE,GAA6ED,CAAC,CAACvE,IAA/E,GAAsF,GAAnG;QACA,OAAO,KAAP;MACH;;MAEDuE,CAAC,CAACC,MAAF,GAAW,KAAK9C,MAAL,CAAY0C,GAAZ,CAAgBG,CAAC,CAACC,MAAlB,CAAX;MACAD,CAAC,CAACvE,IAAF,GAAS,KAAK0B,MAAL,CAAY0C,GAAZ,CAAgBG,CAAC,CAACvE,IAAlB,CAAT;MAEA,IAAIyE,SAAS,GAAGF,CAAC,CAACC,MAAlB;;MACA,KAAK,IAAIE,CAAT,IAAcD,SAAS,CAACvE,WAAV,EAAd,EAAuC;QACnC,IAAII,EAAE,GAAGmE,SAAS,CAACvE,WAAV,GAAwBwE,CAAxB,CAAT;;QACA,IAAKpE,EAAE,CAACnB,IAAH,KAAYoF,CAAC,CAACxE,MAAf,IAA2BO,EAAE,CAAClB,KAAH,KAAamF,CAAC,CAACvE,IAA9C,EAAqD;UACjD,KAAK2B,KAAL,GAAa,iBAAiB4C,CAAC,CAACxE,MAAnB,GAA4B,IAA5B,GAAmCwE,CAAC,CAACC,MAAF,CAAShF,IAA5C,GAAmD,IAAnD,GAA0D+E,CAAC,CAACvE,IAAF,CAAOR,IAAjE,GAAwE,kBAArF;UACA,OAAO,KAAP;QACH;MACJ;;MACDiF,SAAS,CAAC3E,QAAV,CAAmByE,CAAC,CAACxE,MAArB,EAA6BwE,CAAC,CAACvE,IAA/B;MACAuE,CAAC,CAACvE,IAAF,CAAOS,SAAP,CAAiBgE,SAAjB,EAA4BF,CAAC,CAACxE,MAA9B,EA5B4B,CA8B5B;;MACA,IAAI,CAACwE,CAAC,CAACC,MAAF,CAAS7E,IAAT,CAAcgF,QAAd,CAAuBJ,CAAC,CAACvE,IAAzB,CAAL,EAAqC;QACjCuE,CAAC,CAACC,MAAF,CAAS7E,IAAT,CAAcM,IAAd,CAAmBsE,CAAC,CAACvE,IAArB;MACH;IACJ;;IACD,OAAO,IAAP;EACH,CAjRiB,CAmRlB;;;EACAsC,aAAa,CAACsC,KAAD,EAAQ;IACjB,KAAK,IAAIvE,CAAT,IAAcuE,KAAK,CAACjF,IAApB,EAA0B;MACtB,IAAI4C,CAAC,GAAGqC,KAAK,CAACjF,IAAN,CAAWU,CAAX,CAAR;;MACA,IAAI,CAACkC,CAAC,CAAC7C,SAAP,EAAkB;QACd6C,CAAC,CAAC7C,SAAF,GAAc,IAAd;QACA,KAAK4C,aAAL,CAAmBC,CAAnB;MACH;IACJ;EACJ,CA5RiB,CA8RlB;;;EACAO,SAAS,CAAC+B,QAAD,EAAW;IAChB,IAAInC,YAAY,GAAG,EAAnB;IACA,IAAIoC,GAAG,GAAG,KAAKjD,KAAL,CAAWkD,KAAX,CAAiB,EAAjB,CAAV;IACA3D,OAAO,CAACC,GAAR,CAAYyD,GAAG,CAACzB,MAAhB;IACA,IAAI2B,SAAS,GAAGH,QAAhB;IACA,IAAII,OAAO,GAAG,KAAKrD,OAAL,CAAasD,OAAb,EAAd;;IACA,KAAK,IAAI7E,CAAT,IAAc4E,OAAO,CAAC5B,MAAR,GAAe,CAA7B,EAAgC;MAC5B,IAAI8B,GAAG,GAAGL,GAAG,CAAC,CAAD,CAAb;MACA,IAAIM,OAAO,GAAGH,OAAO,CAAC5E,CAAD,CAArB;MACA,IAAIgF,CAAC,GAAG,CAAR;;MACA,KAAK,IAAIxE,GAAT,IAAgBoE,OAAO,CAAC5E,CAAC,GAAC,CAAH,CAAvB,EAA8B;QAC1B,IAAI2E,SAAS,CAACpE,MAAV,CAAiBC,GAAjB,EAAsBkD,GAAtB,CAA0BoB,GAA1B,CAAJ,EAAoC;UAChC,IAAIG,QAAQ,GAAG,IAAIrG,IAAJ,CAAS+F,SAAT,EAAoBG,GAApB,CAAf;UACAzC,YAAY,CAACzC,IAAb,CAAkBqF,QAAlB;UACAN,SAAS,GAAGnE,GAAZ;UACAiE,GAAG,CAACS,GAAJ;UACA;QACH,CAND,MAOK,IAAIP,SAAS,CAACpE,MAAV,CAAiBC,GAAjB,EAAsBkD,GAAtB,CAA0B,KAA1B,CAAJ,EAAsC;UACvC,IAAIuB,QAAQ,GAAG,IAAIrG,IAAJ,CAAS+F,SAAT,EAAoB,GAApB,CAAf;UACAtC,YAAY,CAACzC,IAAb,CAAkBqF,QAAlB;UACAN,SAAS,GAAGnE,GAAZ;UACA;QACH;MACJ,CAlB2B,CAmB5B;;IACH;EAEJ;;AA3TiB,C,CA8TtB;;AACA,OAAO,SAASU,cAAT,CAAwBM,KAAxB,EAA+B;EAClCA,KAAK,GAAGA,KAAK,CAAC2D,UAAN,CAAiB,GAAjB,EAAsB,EAAtB,CAAR;EACA,IAAI3D,KAAK,CAACwB,MAAN,KAAiB,CAArB,EAAwB,OAAO,EAAP;EACxB,IAAIoC,WAAW,GAAG5D,KAAK,CAACkD,KAAN,CAAY,GAAZ,CAAlB;EACA,IAAIW,YAAY,GAAG,EAAnB;;EACA,KAAK,IAAIrF,CAAT,IAAcoF,WAAd,EAA2B;IACvB,IAAIE,SAAS,GAAGF,WAAW,CAACpF,CAAD,CAA3B;IACAqF,YAAY,CAACrF,CAAD,CAAZ,GAAkB,IAAId,QAAJ,CAAaoG,SAAb,CAAlB;EACH;;EACD,OAAOD,YAAP;AACH"},"metadata":{},"sourceType":"module"}