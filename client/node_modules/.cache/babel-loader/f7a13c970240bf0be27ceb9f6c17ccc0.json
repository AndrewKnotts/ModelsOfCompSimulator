{"ast":null,"code":"var inputAlphabet = \"\";\nvar pushdownAlphabet = \"\";\nvar states = \"\";\nvar transitions = \"\";\nvar stack = \"\";\nvar initialState = \"\";\nvar final = \"\";\nvar model = \"\";\nvar initialStack = \"\"; // leftmost char will be top of stack\n\nvar all = \"\";\n\nfunction parseStates(input) {\n  //console.log(\"Parsing States\");\n  let input_array = input.split(',');\n  let states_array = [];\n\n  for (let i in input_array) {\n    let str_state = input_array[i];\n    states_array[i] = new State(str_state.replace(\" \", \"\"));\n  }\n\n  return states_array;\n}\n\nfunction parseInputAlphabet(input) {\n  //console.log(\"Paring Input Alphabet\");\n  let inputAlphabet_array = input.split(',');\n\n  for (let i in inputAlphabet_array) {\n    let alpha = inputAlphabet_array[i];\n    inputAlphabet_array[i] = alpha.replace(\" \", \"\");\n  }\n\n  return inputAlphabet_array;\n}\n\nfunction parsePushdownAlphabet(input) {\n  console.log(\"parsing pushdown alphabet: \" + input);\n  let pushdownAlphabet_array = input.split(',');\n\n  for (let i in pushdownAlphabet_array) {\n    let alpha = pushdownAlphabet_array[i];\n    pushdownAlphabet_array[i] = alpha.replace(\" \", \"\");\n  }\n\n  return pushdownAlphabet_array;\n} // (q0, a, S) -> (q1, S); (q1, e, S) -> (q2, SS); ...\n\n\nfunction parseTransitions(input) {\n  //console.log(\"Parsing Transitions\");\n  let transitions = input.split(';');\n  let transArray = [];\n\n  for (let i in transitions) {\n    let pair = transitions[i].split(\" -> \");\n    let src = pair[0].split(','); //(q0, a, Z)\n\n    let dest = pair[1].split(','); // (q1, A)\n\n    for (let j in src) {\n      src[j] = src[j].replace(\" \", \"\").replace(\"(\", \"\").replace(\")\", \"\");\n    }\n\n    dest[0] = dest[0].replace(\" \", \"\").replace(\"(\", \"\");\n    dest[1] = dest[1].replace(\" \", \"\").replace(\")\", \"\");\n    let state1 = new State(src[0]);\n    let state2 = new State(dest[0]);\n    transArray[i] = new Transition(state1, state2, src[1], src[2], dest[1]);\n  }\n\n  return transArray;\n}\n\nexport class State {\n  // same as DFA\n  constructor(name) {\n    this.name = name;\n    this.accepting = false;\n    this.connected = false;\n    this.conn = [];\n  }\n\n}\nexport class Transition {\n  // (source, input, stack0) -> (dest, stack1)\n  constructor(source, dest, input, stack0, stack1) {\n    this.input = input;\n    this.source = source;\n    this.dest = dest;\n    this.stack0 = stack0;\n    this.stack1 = stack1;\n  }\n\n  static getDest() {\n    return this.dest;\n  }\n\n}\nexport class PDAModel {\n  constructor(all_states, initialState, inputAlphabet, pushdownAlphabet, transitions, initialStack, accepting) {\n    this.all = parseStates(all_states);\n    this.pushdownAlphabet = parsePushdownAlphabet(pushdownAlphabet);\n    this.transitions = parseTransitions(transitions);\n    this.inputAlphabet = parseInputAlphabet(inputAlphabet);\n    this.initialStack = initialStack;\n    this.accepting = parseStates(accepting);\n    this.inputSyms = null;\n    this.pdSyms = null; //this.ts = new Map();\n\n    this.srcToInput = new Map();\n    this.srcToStack = new Map();\n    this.currentState = null;\n    this.currentStack = null;\n    this.epsTransitions = [];\n    if (!this.checkInputAlphabet()) console.log(\"Invalid Input Alphabet\"); //console.log(this.pushdownAlphabet.size);\n\n    if (!this.checkPushdownAlphabet()) console.log(\"Invalid Pushdown alphabet: \" + pushdownAlphabet); //console.log(\"here\");\n\n    if (!this.checkInitialStack()) console.log(\"Invalid Initial Stack\");\n    if (!this.checkStates()) console.log(\"Invalid states\"); //if (!this.checkInitialState()) console.log(\"Invalid initial state\");\n    //else {\n    //   this.initialState = this.getInitialState(initialState);\n    //}\n\n    if (!this.getInitialState(initialState)) console.log(\"Invalid Initial State\");\n    if (!this.checkAccepting()) console.log(\"Invalid Accepting array\");\n    if (!this.checkTransitions()) console.log(\"Invalid transitions\"); //if (!this.checkDeterministic()) console.log(\"Non-deterministic\");\n    //else console.log(\"Deterministic\");\n\n    if (states.length > 1) {\n      this.makeConnected(this.initialState);\n\n      for (let i in this.all) {\n        let s = this.all[i];\n\n        if (!s.connected) {\n          console.log(\"State \" + s.name + \" is not reachable.\");\n        }\n      }\n    }\n  }\n\n  getInitialState(name) {\n    if (name == null || name == \"\") return false;\n\n    for (let i in this.all) {\n      let st = this.all[i];\n\n      if (st.name === name) {\n        this.initialState = st;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  checkInputString(input) {\n    this.currentState = this.initialState;\n    this.currentStack = this.initialStack;\n    let path = []; // path is gonna have each transition object\n\n    for (let i = 0; i < input.length; i++) {\n      let sym = input.substring(i, i + 1);\n      let worked = false;\n      let epsTran = null;\n\n      for (let j in this.transitions) {\n        let t = this.transitions[j];\n        let currStackChar = t.stack0 === \"eps\" ? \"\" : t.stack0;\n\n        if (t.source === this.currentState && t.input === sym && currStackChar === this.currentStack.substring(0, 1)) {\n          path.push(t);\n          this.currentState = t.dest;\n          if (t.stack1 != \"eps\") this.currentStack = t.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n          worked = true;\n          break;\n        } else if (t.input == \"eps\" && t.source == this.currentState && t.stack0 == this.currentStack.substring(0, 1)) {\n          epsTran = t;\n        }\n      }\n\n      if (!worked && epsTran != null) {\n        path.push(epsTran);\n        this.currentState = epsTran.dest;\n        if (epsTran.stack1 != \"eps\") this.currentStack = epsTran.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n        i--;\n      } else if (!worked) {\n        console.log(\"No transition suitable\");\n        return false;\n      }\n    }\n\n    while (this.currentStack != \"\") {\n      let worked = false;\n\n      for (let j in this.epsTransitions) {\n        let et = this.epsTransitions[j];\n\n        if (et.source === this.currentState && this.currentStack.substring(0, 1) === et.stack0) {\n          path.push(et);\n          this.currentState = et.dest;\n          if (et.stack1 != \"eps\") this.currentStack = et.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n          worked = true;\n        }\n      }\n\n      if (!worked) {\n        console.log(\"non-empty stack\");\n        return false;\n      }\n    }\n\n    let endState = false;\n\n    for (let i in this.accepting) {\n      let s = this.accepting[i];\n\n      if (s.name === this.currentState.name) {\n        endState = true;\n        break;\n      }\n    }\n\n    if (endState) return path;else {\n      console.log(\"Not in end state\");\n      return false;\n    }\n  }\n\n  checkInputAlphabet() {\n    if (this.inputAlphabet.size === 0) return false;\n    let symbols = new Set();\n\n    for (let s in this.inputAlphabet) {\n      let i = this.inputAlphabet[s];\n      if (symbols.has(i)) return false;\n      symbols.add(i);\n    }\n\n    this.inputSyms = symbols;\n    return true;\n  }\n\n  checkPushdownAlphabet() {\n    if (this.pushdownAlphabet.size == 0) return false;\n    let symbols = new Set();\n\n    for (let s in this.pushdownAlphabet) {\n      let i = this.pushdownAlphabet[s];\n      if (symbols.has(i) || this.inputSyms.has(i)) return false;\n      symbols.add(i);\n    }\n\n    this.pdSyms = symbols; //console.log(this.pdSyms.size());\n\n    return true;\n  }\n\n  checkStates() {\n    if (this.all.size == 0) return false;\n    let states = new Map();\n\n    for (let i in this.all) {\n      let s = this.all[i];\n      if (states != null && (states.has(s.name) || this.pdSyms.has(s.name) || this.inputSyms.has(s.name))) return false;\n      states.set(s.name, s);\n    }\n\n    this.states = states;\n    return true;\n  }\n\n  checkInitialState() {\n    if (this.states.has(this.initialState.name)) {\n      //this.initialState = this.states.has(initialState.name);\n      this.initialState.connected = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  checkInitialStack() {\n    console.log(this.initialStack);\n\n    for (let i in initialStack) {\n      let sym = initialStack.substring(i, i + 1);\n\n      if (!this.pdSyms.has(sym)) {\n        //this.initialStack = this.pdSyms.get(initialStack)\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  checkAccepting() {\n    for (let i in all) {\n      let s = all[i];\n      if (!this.states.has(s)) return false;\n      s.accepting = true;\n      this.accepting.push(s);\n    }\n\n    return true;\n  }\n\n  checkTransitions() {\n    if (this.transitions.size === 0) return false;\n\n    for (let i in this.transitions) {\n      let t = this.transitions[i];\n      if (t.input != \"eps\" && !this.inputSyms.has(t.input)) return false; // must accept empty\n\n      if (t.stack0 != \"eps\" && !this.pdSyms.has(t.stack0)) return false;\n      let st = false;\n      let end = false;\n\n      for (let x in this.all) {\n        let cc = this.all[x];\n        if (st && end) break;\n\n        if (cc.name === t.source.name) {\n          st = true;\n          t.source = cc;\n        }\n\n        if (cc.name === t.dest.name) {\n          end = true;\n          t.dest = cc;\n        }\n      }\n\n      if (!(st && end)) return false; // check new stack:\n\n      if (t.stack1 != \"eps\") {\n        for (let x in t.stack1) {\n          let c = t.stack1.substring(x, x + 1);\n          if (!this.pdSyms.has(c)) return false;\n        }\n      }\n\n      if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input) && this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n        return false;\n      } // doesn't have the stack symbol yet\n      else if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input)) {\n        let symList = this.srcToInput.get(t.source);\n        symList.push(t.input);\n        this.srcToInput.set(t.source, symList);\n      } // doesnt have the input symbol yet\n      else if (this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n        let symList = this.srcToStack.get(t.source);\n        symList.push(t.stack0);\n        this.srcToStack.set(t.source, symList);\n      } // has the source, but neither the symbol nor the input\n      else if (this.srcToStack.has(t.source) && this.srcToInput.has(t.source)) {\n        let inList = this.srcToInput.get(t.source);\n        inList.push(t.input);\n        this.srcToInput.set(t.source, inList);\n        let stackList = this.srcToStack.get(t.source);\n        stackList.push(t.stack0);\n        this.srcToStack.set(t.source, inList);\n      } // state has yet to be recorded as a source\n      else {\n        let inList = new Array(t.input);\n        let stList = new Array(t.stack0);\n        this.srcToInput.set(t.source, inList);\n        this.srcToStack.set(t.source, stList);\n      }\n\n      if (!t.source.conn.includes(t.dest) && t.source.name != t.dest.name) {\n        t.source.conn.push(t.dest);\n        t.source.connected = true;\n        if (t.source.name === this.initialState.name) this.initialState = t.source;\n      } // Adding to list of Transitions with eps as input\n\n\n      if (t.input === \"eps\") {\n        this.epsTransitions.push(t);\n      }\n    }\n\n    return true;\n  }\n\n  makeConnected(start) {\n    for (let i in start.conn) {\n      let s = start.conn[i];\n\n      if (!s.connected) {\n        s.connected = true;\n        this.makeConnected(s);\n      }\n    }\n  }\n\n}\nlet states1 = \"q0, q1\";\nlet startState1 = \"q0\";\nlet inputAlphabet1 = \"a, b\";\nlet pushdownAlphabet1 = \"A, Z\";\nlet transitions1 = \"(q0, a, Z) -> (q0, AZ); (q0, a, A) -> (q0, AA); (q0, b, A) -> (q1, eps); (q1, b, A) -> (q1, eps); (q1, eps, Z) -> (q1, eps)\";\nlet startStack1 = \"Z\";\nlet accepting1 = \"q1\";\nlet astring1 = \"aaabbb\"; // Z\n\nlet astring2 = \"aaaabbbb\"; // Z\n\nlet astring3 = \"abbb\"; // AZAZ\n\nlet astring4 = \"bbbbb\"; // AAAAA\n\nlet astring5 = \"bbb\"; // AZAZAZZZZ\n\nlet rstring1 = \"aabbba\"; // A, Z, AAZ\n\nlet rstring2 = \"\"; // anything: A, Z, AA, AAZZ\n\nlet rstring3 = \"ab\"; // Z\n\nlet rstring4 = \"a\"; // Z, A\n\nlet rstring5 = \"aaabbb\"; // AA, A\n\n/*\nlet Z_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"Z\", accepting1);\nlet A_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"A\", accepting1);\nlet AA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AA\", accepting1);\nlet AAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAZ\", accepting1);\nlet AZAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZ\", accepting1);\nlet AAAAA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAAAA\", accepting1);\nlet AZAZAZZZZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZAZZZZ\", accepting1);\n*/\n\n/* TESTS: change return statement of checkInputString from return path; to return true; to test again\n// Accept\nif (Z_PDA.checkInputString(\"aaabbb\")) console.log(\"test1: correct output - passed\");\nelse console.log(\"test1: failed\");\n\nif (Z_PDA.checkInputString(astring2)) console.log(\"test2: correct output - passed\")\nelse console.log(\"test2: failed\");\n\n//Wrong test here\nif (AZAZ_PDA.checkInputString(\"abbb\")) console.log(\"test3: correct output - passed\");\nelse console.log(\"test3: failed\"); \n\nif (AAAAA_PDA.checkInputString(\"bbbbb\")) console.log(\"test4: correct output - passed\");\nelse console.log(\"test4: failed\");\n\nif (AZAZAZZZZ_PDA.checkInputString(\"bbb\")) console.log(\"test5: correct output - passed\");\nelse console.log(\"test5: failed\"); \n\nif (Z_PDA.checkInputString(\"ab\")) console.log(\"test13: correct output - passed\");\nelse console.log(\"test13: failed\");\n\nif (A_PDA.checkInputString(\"aaabbbb\")) console.log(\"test16: correct output - passed\");\nelse console.log(\"test16: failed\");\n\n// Reject\nif (!A_PDA.checkInputString(\"aabbba\")) console.log(\"test6: correct output - rejected\");\nelse console.log(\"test6: failed\");\n\nif (!Z_PDA.checkInputString(\"aabbba\")) console.log(\"test7: correct output - rejected\");\nelse console.log(\"test7: failed\");\n\nif (!AAZ_PDA.checkInputString(\"aabbba\")) console.log(\"test8: correct output - rejected\");\nelse console.log(\"test8: failed\");\n\nif (!A_PDA.checkInputString(\"\")) console.log(\"test9: correct output - rejected\");\nelse console.log(\"test9: failed\");\n\nif (!Z_PDA.checkInputString(\"\")) console.log(\"test10: correct output - rejected\");\nelse console.log(\"test10: failed\");\n\nif (!AAZ_PDA.checkInputString(\"\")) console.log(\"test11: correct output - rejected\");\nelse console.log(\"test11: failed\");\n\nif (!AAAAA_PDA.checkInputString(\"\")) console.log(\"test12: correct output - rejected\");\nelse console.log(\"test12: failed\");\n\nif (!Z_PDA.checkInputString(\"a\")) console.log(\"test14: correct output - rejected\");\nelse console.log(\"test14: failed\");\n\nif (!A_PDA.checkInputString(\"a\")) console.log(\"test15: correct output - rejected\");\nelse console.log(\"test15: failed\");\n\nif (!AA_PDA.checkInputString(\"aaabbbb\")) console.log(\"test17: correct output - rejected\");\nelse console.log(\"test17: failed\");\n*/\n// Palindrome PDA\n\nlet states2 = \"s, f\";\nlet transitions2 = \"(s, a, eps) -> (s, A); (s, b, eps) -> (s, B); (s, c, eps) -> (f, eps); (f, a, A) -> (f, eps); (f, b, B) -> (f, eps)\";\nlet startstate2 = \"s\";\nlet initialStack2 = \"\";\nlet inputAlphabet2 = \"a, b, c\";\nlet pushdownAlphabet2 = \"A, B\";\nlet accepting2 = \"f\"; //let testPDA2 = new PDAModel(states2, startstate2, inputAlphabet2, pushdownAlphabet2, transitions2, initialStack2, accepting2);\n//console.log(testPDA2.checkInputString(\"aaabbb\"));\n//let simplePDA = new PDAModel(\"q0\", \"q0\", \"a,b\", \"A\", \"(q0, a, A) -> (q0, eps); (q0, b, eps) -> (q0, A)\", \"A\", \"q0\");\n//console.log(simplePDA.checkInputString(\"aba\"));","map":{"version":3,"names":["inputAlphabet","pushdownAlphabet","states","transitions","stack","initialState","final","model","initialStack","all","parseStates","input","input_array","split","states_array","i","str_state","State","replace","parseInputAlphabet","inputAlphabet_array","alpha","parsePushdownAlphabet","console","log","pushdownAlphabet_array","parseTransitions","transArray","pair","src","dest","j","state1","state2","Transition","constructor","name","accepting","connected","conn","source","stack0","stack1","getDest","PDAModel","all_states","inputSyms","pdSyms","srcToInput","Map","srcToStack","currentState","currentStack","epsTransitions","checkInputAlphabet","checkPushdownAlphabet","checkInitialStack","checkStates","getInitialState","checkAccepting","checkTransitions","length","makeConnected","s","st","checkInputString","path","sym","substring","worked","epsTran","t","currStackChar","push","concat","et","endState","size","symbols","Set","has","add","set","checkInitialState","end","x","cc","c","get","includes","symList","inList","stackList","Array","stList","start","states1","startState1","inputAlphabet1","pushdownAlphabet1","transitions1","startStack1","accepting1","astring1","astring2","astring3","astring4","astring5","rstring1","rstring2","rstring3","rstring4","rstring5","states2","transitions2","startstate2","initialStack2","inputAlphabet2","pushdownAlphabet2","accepting2"],"sources":["/Users/simonlow/Documents/ModelsOfCompSimulator-2/client/src/components/input/PDAModel.js"],"sourcesContent":["var inputAlphabet = \"\"\nvar pushdownAlphabet = \"\"\nvar states = \"\"\nvar transitions = \"\"\nvar stack = \"\"\nvar initialState = \"\"\nvar final = \"\"\nvar model = \"\"\nvar initialStack = \"\" // leftmost char will be top of stack\nvar all = \"\"\n\n\nfunction parseStates(input) {\n    //console.log(\"Parsing States\");\n    let input_array = input.split(',');\n    let states_array = [];\n    for (let i in input_array) {\n        let str_state = input_array[i];\n        states_array[i] = new State(str_state.replace(\" \", \"\"));\n    }\n    return states_array;\n}\n\nfunction parseInputAlphabet(input) {\n    //console.log(\"Paring Input Alphabet\");\n    let inputAlphabet_array = input.split(',');\n    for (let i in inputAlphabet_array) {\n        let alpha = inputAlphabet_array[i];\n        inputAlphabet_array[i] = alpha.replace(\" \", \"\");\n    }\n    return inputAlphabet_array;\n}\n\nfunction parsePushdownAlphabet(input) {\n    console.log(\"parsing pushdown alphabet: \" + input);\n    let pushdownAlphabet_array = input.split(',');\n    for (let i in pushdownAlphabet_array) {\n        let alpha = pushdownAlphabet_array[i];\n        pushdownAlphabet_array[i] = alpha.replace(\" \", \"\");\n    }\n    return pushdownAlphabet_array;\n}\n\n// (q0, a, S) -> (q1, S); (q1, e, S) -> (q2, SS); ...\nfunction parseTransitions(input) {\n    //console.log(\"Parsing Transitions\");\n    let transitions = input.split(';');\n    let transArray = [];\n    for (let i in transitions) {\n        let pair = transitions[i].split(\" -> \");\n        let src = pair[0].split(','); //(q0, a, Z)\n        let dest = pair[1].split(','); // (q1, A)\n\n        for (let j in src) {\n            src[j] = src[j].replace(\" \", \"\").replace(\"(\", \"\").replace(\")\", \"\");\n        }\n        dest[0] = dest[0].replace(\" \", \"\").replace(\"(\", \"\");\n        dest[1] = dest[1].replace(\" \", \"\").replace(\")\", \"\");\n\n        let state1 = new State(src[0]);\n        let state2 = new State(dest[0]);\n\n        transArray[i] = new Transition(state1, state2, src[1], src[2], dest[1]);\n    }\n    return transArray;\n}\n\nexport class State { // same as DFA\n    constructor(name) {\n        this.name = name;\n        this.accepting = false;\n        this.connected = false;\n        this.conn = [];\n    }\n}\n\nexport class Transition { // (source, input, stack0) -> (dest, stack1)\n    constructor(source, dest, input, stack0, stack1) {\n        this.input = input;\n        this.source = source;\n        this.dest = dest;\n        this.stack0 = stack0;\n        this.stack1 = stack1;\n    }\n\n    static getDest() {\n        return this.dest;\n    }\n}\n\nexport class PDAModel {\n    constructor(all_states, initialState, inputAlphabet, pushdownAlphabet, transitions, initialStack, accepting) {\n        this.all = parseStates(all_states);\n        this.pushdownAlphabet = parsePushdownAlphabet(pushdownAlphabet);\n        this.transitions = parseTransitions(transitions);\n        this.inputAlphabet = parseInputAlphabet(inputAlphabet);\n        this.initialStack = initialStack;\n        this.accepting = parseStates(accepting);\n        this.inputSyms = null;\n        this.pdSyms = null;\n        //this.ts = new Map();\n        this.srcToInput = new Map();\n        this.srcToStack = new Map();\n        this.currentState = null;\n        this.currentStack = null;\n        this.epsTransitions = [];\n\n\n\n        if (!this.checkInputAlphabet()) console.log(\"Invalid Input Alphabet\");\n        //console.log(this.pushdownAlphabet.size);\n        if (!this.checkPushdownAlphabet()) console.log(\"Invalid Pushdown alphabet: \" + pushdownAlphabet);\n        //console.log(\"here\");\n        if (!this.checkInitialStack()) console.log(\"Invalid Initial Stack\");\n        if (!this.checkStates()) console.log(\"Invalid states\");\n        //if (!this.checkInitialState()) console.log(\"Invalid initial state\");\n        //else {\n        //   this.initialState = this.getInitialState(initialState);\n        //}\n        if (!this.getInitialState(initialState)) console.log(\"Invalid Initial State\");\n        if (!this.checkAccepting()) console.log(\"Invalid Accepting array\");\n        if (!this.checkTransitions()) console.log(\"Invalid transitions\");\n        //if (!this.checkDeterministic()) console.log(\"Non-deterministic\");\n        //else console.log(\"Deterministic\");\n\n        if (states.length > 1) {\n            this.makeConnected(this.initialState);\n            for (let i in this.all) {\n                let s = this.all[i];\n                if (!s.connected) {\n                    console.log(\"State \" + s.name + \" is not reachable.\");\n                }\n            }\n        }\n    }\n\n    getInitialState(name) {\n        if (name == null || name == \"\") return false;\n        for (let i in this.all) {\n            let st = this.all[i];\n            if (st.name === name) {\n                this.initialState = st;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    checkInputString(input) {\n        this.currentState = this.initialState;\n        this.currentStack = this.initialStack;\n        let path = []; // path is gonna have each transition object\n\n        for (let i = 0; i < input.length; i++) {\n            let sym = input.substring(i, i + 1);\n            let worked = false;\n            let epsTran = null;\n            for (let j in this.transitions) {\n                let t = this.transitions[j];\n                let currStackChar = (t.stack0 === \"eps\") ? \"\" : t.stack0;\n                if ((t.source === this.currentState) && (t.input === sym) && (currStackChar === this.currentStack.substring(0, 1))) {\n                    path.push(t);\n                    this.currentState = t.dest;\n                    if (t.stack1 != \"eps\") this.currentStack = t.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));\n                    else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n                    worked = true;\n                    break;\n                }\n                else if ((t.input == \"eps\") && (t.source == this.currentState) && (t.stack0 == this.currentStack.substring(0, 1))) {\n                    epsTran = t;\n                }\n            }\n            if (!worked && epsTran != null) {\n                path.push(epsTran);\n                this.currentState = epsTran.dest;\n                if (epsTran.stack1 != \"eps\") this.currentStack = epsTran.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));\n                else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n                i--;\n            }\n            else if (!worked) {\n                console.log(\"No transition suitable\");\n                return false;\n            }\n        }\n        while (this.currentStack != \"\") {\n            let worked = false;\n            for (let j in this.epsTransitions) {\n                let et = this.epsTransitions[j];\n                if (et.source === this.currentState && this.currentStack.substring(0, 1) === et.stack0) {\n                    path.push(et);\n                    this.currentState = et.dest;\n                    if (et.stack1 != \"eps\") this.currentStack = et.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));\n                    else this.currentStack = this.currentStack.substring(1, this.currentStack.length);\n                    worked = true;\n                }\n            }\n            if (!worked) {\n                console.log(\"non-empty stack\");\n                return false;\n\n            }\n        }\n\n        let endState = false;\n        for (let i in this.accepting) {\n            let s = this.accepting[i];\n            if (s.name === this.currentState.name) {\n                endState = true;\n                break;\n            }\n        }\n\n        if (endState) return path;\n        else {\n            console.log(\"Not in end state\");\n            return false;\n        }\n    }\n\n    checkInputAlphabet() {\n        if (this.inputAlphabet.size === 0) return false;\n        let symbols = new Set();\n        for (let s in this.inputAlphabet) {\n            let i = this.inputAlphabet[s];\n            if (symbols.has(i)) return false;\n            symbols.add(i);\n        }\n\n        this.inputSyms = symbols;\n        return true;\n    }\n\n    checkPushdownAlphabet() {\n        if (this.pushdownAlphabet.size == 0) return false;\n\n        let symbols = new Set();\n        for (let s in this.pushdownAlphabet) {\n            let i = this.pushdownAlphabet[s];\n            if (symbols.has(i) || this.inputSyms.has(i)) return false;\n            symbols.add(i);\n        }\n\n        this.pdSyms = symbols;\n        //console.log(this.pdSyms.size());\n        return true;\n    }\n\n    checkStates() {\n        if (this.all.size == 0) return false;\n\n        let states = new Map();\n        for (let i in this.all) {\n            let s = this.all[i];\n            if (states != null && (states.has(s.name) || this.pdSyms.has(s.name) || this.inputSyms.has(s.name))) return false;\n            states.set(s.name, s);\n        }\n\n        this.states = states;\n        return true;\n    }\n\n    checkInitialState() {\n        if (this.states.has(this.initialState.name)) {\n            //this.initialState = this.states.has(initialState.name);\n            this.initialState.connected = true;\n            return true;\n        }\n        return false;\n    }\n\n    checkInitialStack() {\n        console.log(this.initialStack);\n        for (let i in initialStack) {\n            let sym = initialStack.substring(i, i + 1);\n            if (!this.pdSyms.has(sym)) {\n                //this.initialStack = this.pdSyms.get(initialStack)\n                return false\n            }\n        }\n\n        return true;\n    }\n\n    checkAccepting() {\n        for (let i in all) {\n            let s = all[i];\n            if (!this.states.has(s)) return false;\n            s.accepting = true;\n            this.accepting.push(s);\n        }\n        return true;\n\n    }\n\n    checkTransitions() {\n        if (this.transitions.size === 0) return false;\n\n        for (let i in this.transitions) {\n            let t = this.transitions[i];\n            if (t.input != \"eps\" && !this.inputSyms.has(t.input)) return false; // must accept empty\n            if (t.stack0 != \"eps\" && !this.pdSyms.has(t.stack0)) return false;\n            let st = false;\n            let end = false;\n            for (let x in this.all) {\n                let cc = this.all[x];\n                if (st && end) break;\n                if (cc.name === t.source.name) {\n                    st = true;\n                    t.source = cc;\n                }\n                if (cc.name === t.dest.name) {\n                    end = true;\n                    t.dest = cc;\n                }\n\n            }\n            if (!(st && end)) return false;\n\n            // check new stack:\n            if (t.stack1 != \"eps\") {\n                for (let x in t.stack1) {\n                    let c = t.stack1.substring(x, x + 1);\n                    if (!this.pdSyms.has(c)) return false;\n                }\n            }\n\n            if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input)\n                && this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n                return false;\n            }\n            // doesn't have the stack symbol yet\n            else if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input)) {\n                let symList = this.srcToInput.get(t.source);\n                symList.push(t.input);\n                this.srcToInput.set(t.source, symList);\n            }\n            // doesnt have the input symbol yet\n            else if (this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n                let symList = this.srcToStack.get(t.source);\n                symList.push(t.stack0);\n                this.srcToStack.set(t.source, symList);\n            }\n            // has the source, but neither the symbol nor the input\n            else if (this.srcToStack.has(t.source) && this.srcToInput.has(t.source)) {\n                let inList = this.srcToInput.get(t.source);\n                inList.push(t.input);\n                this.srcToInput.set(t.source, inList);\n                let stackList = this.srcToStack.get(t.source);\n                stackList.push(t.stack0);\n                this.srcToStack.set(t.source, inList);\n            }\n            // state has yet to be recorded as a source\n            else {\n                let inList = new Array(t.input);\n                let stList = new Array(t.stack0);\n                this.srcToInput.set(t.source, inList);\n                this.srcToStack.set(t.source, stList);\n            }\n\n            if (!t.source.conn.includes(t.dest) && t.source.name != t.dest.name) {\n                t.source.conn.push(t.dest);\n                t.source.connected = true;\n                if (t.source.name === this.initialState.name) this.initialState = t.source;\n            }\n\n            // Adding to list of Transitions with eps as input\n            if (t.input === \"eps\") {\n                this.epsTransitions.push(t);\n            }\n        }\n        return true;\n    }\n\n    makeConnected(start) {\n        for (let i in start.conn) {\n            let s = start.conn[i];\n            if (!s.connected) {\n                s.connected = true;\n                this.makeConnected(s);\n            }\n        }\n    }\n}\n\nlet states1 = \"q0, q1\";\nlet startState1 = \"q0\";\nlet inputAlphabet1 = \"a, b\";\nlet pushdownAlphabet1 = \"A, Z\";\nlet transitions1 = \"(q0, a, Z) -> (q0, AZ); (q0, a, A) -> (q0, AA); (q0, b, A) -> (q1, eps); (q1, b, A) -> (q1, eps); (q1, eps, Z) -> (q1, eps)\"\nlet startStack1 = \"Z\";\nlet accepting1 = \"q1\";\n\nlet astring1 = \"aaabbb\"; // Z\nlet astring2 = \"aaaabbbb\"; // Z\nlet astring3 = \"abbb\"; // AZAZ\nlet astring4 = \"bbbbb\"; // AAAAA\nlet astring5 = \"bbb\"; // AZAZAZZZZ\n\nlet rstring1 = \"aabbba\"; // A, Z, AAZ\nlet rstring2 = \"\"; // anything: A, Z, AA, AAZZ\nlet rstring3 = \"ab\" // Z\nlet rstring4 = \"a\" // Z, A\nlet rstring5 = \"aaabbb\"; // AA, A\n/*\nlet Z_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"Z\", accepting1);\nlet A_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"A\", accepting1);\nlet AA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AA\", accepting1);\nlet AAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAZ\", accepting1);\nlet AZAZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZ\", accepting1);\nlet AAAAA_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AAAAA\", accepting1);\nlet AZAZAZZZZ_PDA = new PDAModel(states1, startState1, inputAlphabet1, pushdownAlphabet1, transitions1, \"AZAZAZZZZ\", accepting1);\n*/\n\n/* TESTS: change return statement of checkInputString from return path; to return true; to test again\n// Accept\nif (Z_PDA.checkInputString(\"aaabbb\")) console.log(\"test1: correct output - passed\");\nelse console.log(\"test1: failed\");\n\nif (Z_PDA.checkInputString(astring2)) console.log(\"test2: correct output - passed\")\nelse console.log(\"test2: failed\");\n\n//Wrong test here\nif (AZAZ_PDA.checkInputString(\"abbb\")) console.log(\"test3: correct output - passed\");\nelse console.log(\"test3: failed\"); \n\nif (AAAAA_PDA.checkInputString(\"bbbbb\")) console.log(\"test4: correct output - passed\");\nelse console.log(\"test4: failed\");\n\nif (AZAZAZZZZ_PDA.checkInputString(\"bbb\")) console.log(\"test5: correct output - passed\");\nelse console.log(\"test5: failed\"); \n\nif (Z_PDA.checkInputString(\"ab\")) console.log(\"test13: correct output - passed\");\nelse console.log(\"test13: failed\");\n\nif (A_PDA.checkInputString(\"aaabbbb\")) console.log(\"test16: correct output - passed\");\nelse console.log(\"test16: failed\");\n\n// Reject\nif (!A_PDA.checkInputString(\"aabbba\")) console.log(\"test6: correct output - rejected\");\nelse console.log(\"test6: failed\");\n\nif (!Z_PDA.checkInputString(\"aabbba\")) console.log(\"test7: correct output - rejected\");\nelse console.log(\"test7: failed\");\n\nif (!AAZ_PDA.checkInputString(\"aabbba\")) console.log(\"test8: correct output - rejected\");\nelse console.log(\"test8: failed\");\n\nif (!A_PDA.checkInputString(\"\")) console.log(\"test9: correct output - rejected\");\nelse console.log(\"test9: failed\");\n\nif (!Z_PDA.checkInputString(\"\")) console.log(\"test10: correct output - rejected\");\nelse console.log(\"test10: failed\");\n\nif (!AAZ_PDA.checkInputString(\"\")) console.log(\"test11: correct output - rejected\");\nelse console.log(\"test11: failed\");\n\nif (!AAAAA_PDA.checkInputString(\"\")) console.log(\"test12: correct output - rejected\");\nelse console.log(\"test12: failed\");\n\nif (!Z_PDA.checkInputString(\"a\")) console.log(\"test14: correct output - rejected\");\nelse console.log(\"test14: failed\");\n\nif (!A_PDA.checkInputString(\"a\")) console.log(\"test15: correct output - rejected\");\nelse console.log(\"test15: failed\");\n\nif (!AA_PDA.checkInputString(\"aaabbbb\")) console.log(\"test17: correct output - rejected\");\nelse console.log(\"test17: failed\");\n*/\n\n// Palindrome PDA\nlet states2 = \"s, f\";\nlet transitions2 = \"(s, a, eps) -> (s, A); (s, b, eps) -> (s, B); (s, c, eps) -> (f, eps); (f, a, A) -> (f, eps); (f, b, B) -> (f, eps)\";\nlet startstate2 = \"s\";\nlet initialStack2 = \"\";\nlet inputAlphabet2 = \"a, b, c\";\nlet pushdownAlphabet2 = \"A, B\";\nlet accepting2 = \"f\";\n\n//let testPDA2 = new PDAModel(states2, startstate2, inputAlphabet2, pushdownAlphabet2, transitions2, initialStack2, accepting2);\n\n//console.log(testPDA2.checkInputString(\"aaabbb\"));\n\n//let simplePDA = new PDAModel(\"q0\", \"q0\", \"a,b\", \"A\", \"(q0, a, A) -> (q0, eps); (q0, b, eps) -> (q0, A)\", \"A\", \"q0\");\n//console.log(simplePDA.checkInputString(\"aba\"));"],"mappings":"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"},"metadata":{},"sourceType":"module"}