{"ast":null,"code":"var inputAlphabet = \"\";\nvar pushdownAlphabet = \"\";\nvar states = \"\";\nvar transitions = \"\";\nvar stack = \"\";\nvar initialState = \"\";\nvar final = \"\";\nvar model = \"\";\nvar initialStack = \"\"; // leftmost char will be top of stack\n\nvar all = \"\";\n\nfunction parseStates(input) {\n  //console.log(\"Parsing States\");\n  let input_array = input.split(',');\n  let states_array = [];\n\n  for (let i in input_array) {\n    let str_state = input_array[i];\n    states_array[i] = new State(str_state.replace(\" \", \"\"));\n  }\n\n  return states_array;\n}\n\nfunction parseInputAlphabet(input) {\n  //console.log(\"Paring Input Alphabet\");\n  let inputAlphabet_array = input.split(',');\n\n  for (let i in inputAlphabet_array) {\n    let alpha = inputAlphabet_array[i];\n    inputAlphabet_array[i] = alpha.replace(\" \", \"\");\n  }\n\n  return inputAlphabet_array;\n}\n\nfunction parsePushdownAlphabet(input) {\n  //console.log(\"Parsing Pushdown Alphabet\");\n  let pushdownAlphabet_array = input.split(',');\n\n  for (let i in pushdownAlphabet_array) {\n    let alpha = pushdownAlphabet_array[i];\n    pushdownAlphabet_array[i] = alpha.replace(\" \", \"\");\n  }\n\n  return pushdownAlphabet_array;\n} // (q0, a, S) -> (q1, S); (q1, e, S) -> (q2, SS); ...\n\n\nfunction parseTransitions(input) {\n  //console.log(\"Parsing Transitions\");\n  let transitions = input.split(';');\n  let transArray = [];\n\n  for (let i in transitions) {\n    let pair = transitions[i].split(\" -> \");\n    let src = pair[0].split(','); //(q0, a, Z)\n\n    let dest = pair[1].split(','); // (q1, A)\n\n    for (let j in src) {\n      src[j] = src[j].replace(\" \", \"\").replace(\"(\", \"\").replace(\")\", \"\");\n    }\n\n    dest[0] = dest[0].replace(\" \", \"\").replace(\"(\", \"\");\n    dest[1] = dest[1].replace(\" \", \"\").replace(\")\", \"\");\n    let state1 = new State(src[0]);\n    let state2 = new State(dest[0]);\n    transArray[i] = new Transition(state1, state2, src[1], src[2], dest[1]);\n  }\n\n  return transArray;\n}\n\nclass State {\n  // same as DFA\n  constructor(name) {\n    this.name = name;\n    this.accepting = false;\n    this.connected = false;\n    this.conn = [];\n  }\n\n}\n\nclass Transition {\n  // (source, input, stack0) -> (dest, stack1)\n  constructor(source, dest, input, stack0, stack1) {\n    this.input = input;\n    this.source = source;\n    this.dest = dest;\n    this.stack0 = stack0;\n    this.stack1 = stack1;\n  }\n\n  static getDest() {\n    return this.dest;\n  }\n\n}\n\nclass PDAModel {\n  constructor(all_states, initialState, inputAlphabet, pushdownAlphabet, transitions, initialStack, final) {\n    this.all = all_states;\n    this.pushdownAlphabet = pushdownAlphabet;\n    this.transitions = transitions;\n    this.inputAlphabet = inputAlphabet;\n    this.initialStack = initialStack;\n    this.accepting = final;\n    this.inputSyms = null;\n    this.pdSyms = null; //this.ts = new Map();\n\n    this.srcToInput = new Map();\n    this.srcToStack = new Map();\n    this.currentState = null;\n    this.currentStack = null;\n    if (!this.checkInputAlphabet()) console.log(\"Invalid Input Alphabet\"); //console.log(this.pushdownAlphabet.size);\n\n    if (!this.checkPushdownAlphabet()) console.log(\"Invalid Pushdown alphabet\"); //console.log(\"here\");\n\n    if (!this.checkInitialStack()) console.log(\"Invalid Initial Stack\");\n    if (!this.checkStates()) console.log(\"Invalid states\"); //if (!this.checkInitialState()) console.log(\"Invalid initial state\");\n    //else {\n    //   this.initialState = this.getInitialState(initialState);\n    //}\n\n    if (!this.getInitialState(initialState)) console.log(\"Invalid Initial State\");\n    if (!this.checkAccepting()) console.log(\"Invalid Accepting array\");\n    if (!this.checkTransitions()) console.log(\"Invalid transitions\"); //if (!this.checkDeterministic()) console.log(\"Non-deterministic\");\n    //else console.log(\"Deterministic\");\n\n    this.makeConnected(this.initialState);\n\n    for (let i in this.all) {\n      let s = this.all[i];\n\n      if (!s.connected) {\n        console.log(\"State \" + s.name + \" is not reachable.\");\n      }\n    }\n  }\n\n  getInitialState(name) {\n    if (name == null || name == \"\") return false;\n\n    for (let i in this.all) {\n      let st = this.all[i];\n\n      if (st.name === name) {\n        this.initialState = st;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  checkInputString(input) {\n    this.currentState = this.initialState;\n    this.currentStack = this.initialStack;\n    let path = []; // path is gonna have each transition object\n\n    for (let i = 0; i < input.length; i++) {\n      let sym = input.substring(i, i + 1);\n      let worked = false;\n\n      for (let j in this.transitions) {\n        let t = this.transitions[j];\n\n        if (t.source === this.currentState && t.input === sym && t.stack0 === this.currentStack.substring(0, 1)) {\n          path.push(t);\n          this.currentState = t.dest;\n          if (t.stack1 != \"eps\") this.currentStack = t.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));\n          worked = true;\n          break;\n        }\n      }\n\n      if (!worked) return false;\n    }\n\n    let endState = false;\n\n    for (let i in this.accepting) {\n      let s = this.accepting[i];\n\n      if (s.name === this.currentState.name) {\n        endState = true;\n        break;\n      }\n    }\n\n    if (endState) return path;else return false;\n  }\n  /*\n  checkDeterministic() {\n      let symPairs = new Set();\n      for (let i in this.transitions) {\n          let t = this.transitions[i]; \n          let symPair = [t.input, t.stack0];\n          for (let x in symPairs) {\n              let j = symPairs[x];\n              if (t.input == j[0] && t.stack0 === j[1]) return false;\n          }\n          symPairs.add(symPair);\n      }\n      return true; \n  }\n  */\n\n\n  checkInputAlphabet() {\n    if (this.inputAlphabet.size === 0) return false;\n    let symbols = new Set();\n\n    for (let s in this.inputAlphabet) {\n      let i = this.inputAlphabet[s];\n      if (symbols.has(i)) return false;\n      symbols.add(i);\n    }\n\n    this.inputSyms = symbols;\n    return true;\n  }\n\n  checkPushdownAlphabet() {\n    if (this.pushdownAlphabet.size == 0) return false;\n    let symbols = new Set();\n\n    for (let s in this.pushdownAlphabet) {\n      let i = this.pushdownAlphabet[s];\n      if (symbols.has(i) || this.inputSyms.has(i)) return false;\n      symbols.add(i);\n    }\n\n    this.pdSyms = symbols; //console.log(this.pdSyms.size());\n\n    return true;\n  }\n\n  checkStates() {\n    if (this.all.size == 0) return false;\n    let states = new Map();\n\n    for (let i in this.all) {\n      let s = this.all[i];\n      if (states.has(s.name) || this.pdSyms.has(s.name) || this.inputSyms.has(s.name)) return false;\n      states.set(s.name, s);\n    }\n\n    this.states = states;\n    return true;\n  }\n\n  checkInitialState() {\n    if (this.states.has(this.initialState.name)) {\n      //this.initialState = this.states.has(initialState.name);\n      this.initialState.connected = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  checkInitialStack() {\n    for (let i in initialStack) {\n      let sym = initialStack.substring(i, i + 1);\n\n      if (!this.pdSyms.has(sym)) {\n        //this.initialStack = this.pdSyms.get(initialStack)\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  checkAccepting() {\n    for (let i in all) {\n      let s = all[i];\n      if (!this.states.has(s)) return false;\n      s.accepting = true;\n      this.accepting.push(s);\n    }\n\n    return true;\n  }\n\n  checkTransitions() {\n    if (this.transitions.size === 0) return false;\n\n    for (let i in this.transitions) {\n      let t = this.transitions[i];\n      if (t.input != \"eps\" && !this.inputSyms.has(t.input)) return false; // must accept empty\n\n      if (t.stack0 != \"eps\" && !this.pdSyms.has(t.stack0)) return false;\n      let st = false;\n      let end = false;\n\n      for (let x in this.all) {\n        let cc = this.all[x];\n        if (st && end) break;\n\n        if (cc.name === t.source.name) {\n          st = true;\n          t.source = cc;\n        }\n\n        if (cc.name === t.dest.name) {\n          end = true;\n          t.dest = cc;\n        }\n      }\n\n      if (!(st && end)) return false; //if (!this.all.includes(t.source)) return false;\n      //if (!this.all.includes(t.dest)) return false;\n      // check new stack:\n\n      if (t.stack1 != \"eps\") {\n        for (let x in t.stack1) {\n          let c = t.stack1.substring(x, x + 1);\n          if (!this.pdSyms.has(c)) return false;\n        }\n      } //t.source = this.states.get(t.source);\n      //t.dest = this.states.get(t.dest);\n\n\n      if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input) && this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n        return false;\n      } // doesn't have the stack symbol yet\n      else if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input)) {\n        let symList = this.srcToInput.get(t.source);\n        symList.push(t.input);\n        this.srcToInput.set(t.source, symList);\n      } // doesnt have the input symbol yet\n      else if (this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n        let symList = this.srcToStack.get(t.source);\n        symList.push(t.stack0);\n        this.srcToStack.set(t.source, symList);\n      } // has the source, but neither the symbol nor the input\n      else if (this.srcToStack.has(t.source) && this.srcToInput.has(t.source)) {\n        let inList = this.srcToInput.get(t.source);\n        inList.push(t.input);\n        this.srcToInput.set(t.source, inList);\n        let stackList = this.srcToStack.get(t.source);\n        stackList.push(t.stack0);\n        this.srcToStack.set(t.source, inList);\n      } // state has yet to be recorded as a source\n      else {\n        let inList = new Array(t.input);\n        let stList = new Array(t.stack0);\n        this.srcToInput.set(t.source, inList);\n        this.srcToStack.set(t.source, stList);\n      }\n\n      if (!t.source.conn.includes(t.dest) && t.source.name != t.dest.name) {\n        t.source.conn.push(t.dest);\n        t.source.connected = true;\n        if (t.source.name === this.initialState.name) this.initialState = t.source;\n      }\n    }\n\n    return true;\n  }\n\n  makeConnected(start) {\n    for (let i in start.conn) {\n      let s = start.conn[i];\n\n      if (!s.connected) {\n        s.connected = true;\n        this.makeConnected(s);\n      }\n    }\n  }\n\n} // *TESTS*\n\n/*\n// Non-deterministic\nlet q0 = new State(\"q0\");\nlet q1 = new State(\"q1\");\n\nlet t1 = new Transition(q0, q0, \"a\", \"Z\", \"AZ\"); // (q0, a, Z) -> (q0,A)\nlet t2 = new Transition(q0, q0, \"a\", \"A\", \"AA\"); // (q0, a, A) -> (q0, AA)\nlet t3 = new Transition(q0, q1, \"b\", \"A\", \"\"); // (q0, b, A) -> (q1, eps)\nlet t4 = new Transition(q1, q1, \"b\", \"A\", \"\"); // (q1. b. A) -> (q1, eps)\nlet t5 = new Transition(q1, q1, \"\", \"Z\", \"\"); // (q1, eps, Z) -> (q1, eps)\n\nvar test_states = new Array(q0, q1);\nvar test_inAlphabet = new Array(\"a\", \"b\"); //[\"a\", \"b\"];\nvar test_stAlphabet = new Array(\"A\", \"Z\"); //[\"A\", \"Z\"];\n//console.log(test_stAlphabet.length);\nlet test_accepting = [q1];\nlet test_transitions = [t1, t2, t3, t4, t5];\n\nlet testPDA = new PDAModel(test_states, q0, test_inAlphabet, test_stAlphabet, test_transitions, \"Z\", q1);\n\nconsole.log(testPDA.checkInputString(\"aaabbb\"));\n*/\n\n\nlet statebox = \"q0, q1\";\nlet _transitions = \"(q0, a, Z) -> (q0,A); (q0, a, A) -> (q0, AA); (q0, b, A) -> (q1, eps); (q1, b, A) -> (q1, eps); (q1, eps, Z) -> (q1, eps)\";\nlet startstatebox = \"q0\";\nlet startStack = \"Z\";\nlet inputbox = \"a, b\";\nlet stackBox = \"A, Z\";\nlet finalbox = \"q1\";\n\nlet _states = parseStates(statebox);\n\nlet _inAlph = parseInputAlphabet(inputbox);\n\nlet _pdAlph = parsePushdownAlphabet(stackBox);\n\nlet _acc = parseStates(finalbox);\n\nlet _trans = parseTransitions(_transitions);\n\nlet _initSt = startstatebox;\n\nlet _testPDA1 = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, startStack, _acc);\n\nlet astring1 = \"aaabbb\"; // Z\n\nlet astring2 = \"aaaabbbb\"; // Z\n\nlet astring3 = \"abbb\"; // AZAZ\n\nlet astring4 = \"bbbbb\"; // AAAAA\n\nlet astring5 = \"bbb\"; // AZAZAZZZZ\n\nlet rstring1 = \"aabbba\"; // A, Z, AAZ\n\nlet rstring2 = \"\"; // anything: A, Z, AA, AAZZ\n\nlet rstring3 = \"ab\"; // Z\n\nlet rstring4 = \"a\"; // Z, A\n\nlet rstring5 = \"aaabbb\"; // AA, A\n\nif (_testPDA1.checkInputString(astring1)) {\n  console.log(\"test1: correct output\");\n} else console.log(\"fail test1\");\n\nif (_testPDA1.checkInputString(astring2)) {\n  console.log(\"test2: correct output\");\n} else console.log(\"fail test2\");\n\nlet _newTestStates = parseStates(\"q0, q1\");\n\nlet _newTestTransitions = parseTransitions(\"(q0, a, Z) -> (q0,A); (q0, a, A) -> (q0, AA); (q0, b, A) -> (q1, eps); (q1, b, A) -> (q1, eps); (q1, eps, Z) -> (q1, eps)\");\n\nlet _newTestStartState = \"q0\";\nlet _newTestStartStack = \"Z\";\n\nlet _newTestInputAlphabet = parseInputAlphabet(\"a, b\");\n\nlet _newTestPushdownAlphabet = parsePushdownAlphabet(\"A, Z\");\n\nlet _newTestAccepting = parseStates(\"q1\");\n\nlet _testPDA2_withNewObjects = new PDAModel(_newTestStates, _newTestStartState, _newTestInputAlphabet, _newTestPushdownAlphabet, _newTestTransitions, _newTestStartStack, _newTestAccepting);\n\nif (_testPDA2_withNewObjects.checkInputString(astring3)) {\n  console.log(\"new test3: correct output\");\n} else console.log(\"fail new test3\");\n\nlet _testPDA2 = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"AZAZ\", _acc);\n\nif (_testPDA2.checkInputString(astring3)) {\n  console.log(\"test3: correct output\");\n} else console.log(\"fail test3\");\n\nlet _testPDA3 = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"AAAAA\", _acc);\n\nif (_testPDA3.checkInputString(astring4)) {\n  console.log(\"test4: correct output\");\n} else console.log(\"fail test4\");\n\nlet _testPDA4 = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"AZAZAZZZZ\", _acc);\n\nif (_testPDA4.checkInputString(astring5)) {\n  console.log(\"test5: correct output\");\n} else console.log(\"fail test5\");\n\nlet _A_PDA = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"A\", _acc);\n\nlet _Z_PDA = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"Z\", _acc);\n\nlet _AAZ_PDA = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"AAZ\", _acc);\n\nlet _AA_PDA = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"A\", _acc);\n\nif (!_A_PDA.checkInputString(\"aabbba\")) {\n  console.log(\"test6: correct output - rejected\");\n}\n\nif (!_A_PDA.checkInputString(\"a\")) {\n  console.log(\"test7: correct output - rejected\");\n}\n\nif (!_Z_PDA.checkInputString(\"aabbba\")) {\n  console.log(\"test8: correct output - rejected\");\n}\n\nif (!_AAZ_PDA.checkInputString(\"aabbba\")) {\n  console.log(\"test9: correct output - rejected\");\n}\n\nif (!_Z_PDA.checkInputString(\"ab\")) {\n  console.log(\"test10: correct output - rejected\");\n}\n\nif (!_Z_PDA.checkInputString(\"a\")) {\n  console.log(\"test11: correct output - rejected\");\n}\n\nif (!_AA_PDA.checkInputString(\"aaabbb\")) {\n  console.log(\"test12: correct output - rejected\");\n}\n\nif (!_A_PDA.checkInputString(\"aaabbb\")) {\n  console.log(\"test13: correct output - rejected\");\n}\n\nif (!_A_PDA.checkInputString(\"\")) {\n  console.log(\"test14: correct output - rejected\");\n}\n\nif (!_Z_PDA.checkInputString(\"\")) {\n  console.log(\"test15: correct output - rejected\");\n}\n\nif (!_AA_PDA.checkInputString(\"\")) {\n  console.log(\"test16: correct output - rejected\");\n}\n\nif (!_AAZ_PDA.checkInputString(\"\")) {\n  console.log(\"test17: correct output - rejected\");\n} //console.log(t1.input);\n//let transArr = parseTransitions(\"(q0, a, S) -> (q1, S); (q1, e, S) -> (q2, SS)\");\n//console.log(transArr[0].input);\n//console.log(transArr[1].stack1);","map":{"version":3,"names":["inputAlphabet","pushdownAlphabet","states","transitions","stack","initialState","final","model","initialStack","all","parseStates","input","input_array","split","states_array","i","str_state","State","replace","parseInputAlphabet","inputAlphabet_array","alpha","parsePushdownAlphabet","pushdownAlphabet_array","parseTransitions","transArray","pair","src","dest","j","state1","state2","Transition","constructor","name","accepting","connected","conn","source","stack0","stack1","getDest","PDAModel","all_states","inputSyms","pdSyms","srcToInput","Map","srcToStack","currentState","currentStack","checkInputAlphabet","console","log","checkPushdownAlphabet","checkInitialStack","checkStates","getInitialState","checkAccepting","checkTransitions","makeConnected","s","st","checkInputString","path","length","sym","substring","worked","t","push","concat","endState","size","symbols","Set","has","add","set","checkInitialState","end","x","cc","c","get","includes","symList","inList","stackList","Array","stList","start","statebox","_transitions","startstatebox","startStack","inputbox","stackBox","finalbox","_states","_inAlph","_pdAlph","_acc","_trans","_initSt","_testPDA1","astring1","astring2","astring3","astring4","astring5","rstring1","rstring2","rstring3","rstring4","rstring5","_newTestStates","_newTestTransitions","_newTestStartState","_newTestStartStack","_newTestInputAlphabet","_newTestPushdownAlphabet","_newTestAccepting","_testPDA2_withNewObjects","_testPDA2","_testPDA3","_testPDA4","_A_PDA","_Z_PDA","_AAZ_PDA","_AA_PDA"],"sources":["/Users/simonlow/Documents/ModelsOfCompSimulator-2/client/src/components/input/PDAModel.js"],"sourcesContent":["var inputAlphabet = \"\"\nvar pushdownAlphabet = \"\"\nvar states = \"\"\nvar transitions = \"\"\nvar stack = \"\"\nvar initialState = \"\"\nvar final = \"\"\nvar model = \"\"\nvar initialStack = \"\" // leftmost char will be top of stack\nvar all = \"\"\n\n\nfunction parseStates(input) {\n    //console.log(\"Parsing States\");\n    let input_array = input.split(',');\n    let states_array = [];\n    for (let i in input_array) {\n        let str_state = input_array[i];\n        states_array[i] = new State(str_state.replace(\" \", \"\"));\n    }\n    return states_array;\n}\n\nfunction parseInputAlphabet(input) {\n    //console.log(\"Paring Input Alphabet\");\n    let inputAlphabet_array = input.split(',');\n    for (let i in inputAlphabet_array) {\n        let alpha = inputAlphabet_array[i];\n        inputAlphabet_array[i] = alpha.replace(\" \", \"\");\n    }\n    return inputAlphabet_array;\n}\n\nfunction parsePushdownAlphabet(input) {\n    //console.log(\"Parsing Pushdown Alphabet\");\n    let pushdownAlphabet_array = input.split(',');\n    for (let i in pushdownAlphabet_array) {\n        let alpha = pushdownAlphabet_array[i];\n        pushdownAlphabet_array[i] = alpha.replace(\" \", \"\");\n    }\n    return pushdownAlphabet_array;\n}\n\n// (q0, a, S) -> (q1, S); (q1, e, S) -> (q2, SS); ...\nfunction parseTransitions(input) {\n    //console.log(\"Parsing Transitions\");\n    let transitions = input.split(';');\n    let transArray = [];\n    for (let i in transitions) {\n        let pair = transitions[i].split(\" -> \");\n        let src = pair[0].split(','); //(q0, a, Z)\n        let dest = pair[1].split(','); // (q1, A)\n\n        for (let j in src) {\n            src[j] = src[j].replace(\" \", \"\").replace(\"(\", \"\").replace(\")\", \"\");\n        }\n        dest[0] = dest[0].replace(\" \" , \"\").replace(\"(\", \"\");\n        dest[1] = dest[1].replace(\" \", \"\").replace(\")\", \"\");\n\n        let state1 = new State(src[0]);\n        let state2 = new State(dest[0]);\n\n        transArray[i] = new Transition(state1, state2, src[1], src[2], dest[1]);\n    }\n    return transArray; \n}\n\nclass State { // same as DFA\n    constructor(name) {\n        this.name = name;\n        this.accepting = false;\n        this.connected = false;\n        this.conn = [];\n    }\n}\n\nclass Transition { // (source, input, stack0) -> (dest, stack1)\n    constructor(source, dest, input, stack0, stack1) {\n        this.input = input;\n        this.source = source;\n        this.dest = dest;\n        this.stack0 = stack0;\n        this.stack1 = stack1;\n    }\n\n    static getDest() {\n        return this.dest;\n    }\n}\n\nclass PDAModel {\n    constructor(all_states, initialState, inputAlphabet, pushdownAlphabet, transitions, initialStack, final) {\n        this.all = all_states;\n       \n        this.pushdownAlphabet = pushdownAlphabet;\n        this.transitions = transitions;\n        this.inputAlphabet = inputAlphabet;\n        this.initialStack = initialStack;\n        this.accepting = final;\n        this.inputSyms = null;\n        this.pdSyms = null;\n        //this.ts = new Map();\n        this.srcToInput = new Map();\n        this.srcToStack = new Map();\n        this.currentState = null;\n        this.currentStack = null;\n\n        \n        \n        if (!this.checkInputAlphabet()) console.log(\"Invalid Input Alphabet\");\n        //console.log(this.pushdownAlphabet.size);\n        if (!this.checkPushdownAlphabet()) console.log(\"Invalid Pushdown alphabet\");\n        //console.log(\"here\");\n        if (!this.checkInitialStack()) console.log(\"Invalid Initial Stack\");\n        if (!this.checkStates()) console.log(\"Invalid states\");\n        //if (!this.checkInitialState()) console.log(\"Invalid initial state\");\n        //else {\n         //   this.initialState = this.getInitialState(initialState);\n        //}\n        if (!this.getInitialState(initialState)) console.log(\"Invalid Initial State\");\n        if (!this.checkAccepting()) console.log(\"Invalid Accepting array\");\n        if (!this.checkTransitions()) console.log(\"Invalid transitions\");\n        //if (!this.checkDeterministic()) console.log(\"Non-deterministic\");\n        //else console.log(\"Deterministic\");\n\n        this.makeConnected(this.initialState);\n        for (let i in this.all) {\n            let s = this.all[i];\n            if (!s.connected) {\n                console.log(\"State \" + s.name + \" is not reachable.\");\n            }\n        }\n    }\n\n    getInitialState(name) {\n        if (name == null || name == \"\") return false; \n        for (let i in this.all) {\n            let st = this.all[i];\n            if (st.name === name) {\n                this.initialState = st;\n                return true;\n            }\n        }\n        return false; \n    }\n\n    checkInputString(input) {\n        this.currentState = this.initialState;\n        this.currentStack = this.initialStack;\n        let path = []; // path is gonna have each transition object\n        for(let i = 0; i < input.length; i++) {\n            let sym = input.substring(i, i+1);\n            let worked = false;\n            for(let j in this.transitions) {\n                let t = this.transitions[j];\n                if ((t.source === this.currentState) && (t.input === sym) && (t.stack0 === this.currentStack.substring(0, 1))) {\n                    path.push(t);\n                    this.currentState = t.dest;\n                    if (t.stack1 != \"eps\") this.currentStack = t.stack1.concat('', this.currentStack.substring(1, this.currentStack.length));\n                    worked = true;\n                    break;\n                }\n            }   \n            if (!worked) return false;     \n        }\n\n        let endState = false; \n        for (let i in this.accepting) {\n            let s = this.accepting[i];\n            if (s.name === this.currentState.name) {\n                endState = true; \n                break;\n            }\n        }\n        if (endState) return path;\n        else return false; \n    }\n\n    /*\n    checkDeterministic() {\n        let symPairs = new Set();\n        for (let i in this.transitions) {\n            let t = this.transitions[i]; \n            let symPair = [t.input, t.stack0];\n            for (let x in symPairs) {\n                let j = symPairs[x];\n                if (t.input == j[0] && t.stack0 === j[1]) return false;\n            }\n            symPairs.add(symPair);\n        }\n        return true; \n    }\n    */\n\n    checkInputAlphabet() {\n        if (this.inputAlphabet.size === 0) return false;\n        let symbols = new Set();\n        for (let s in this.inputAlphabet) {\n            let i = this.inputAlphabet[s];\n            if (symbols.has(i)) return false;\n            symbols.add(i);\n        }\n\n        this.inputSyms = symbols;\n        return true;\n    }\n    \n    checkPushdownAlphabet() {\n        if (this.pushdownAlphabet.size == 0) return false;\n\n        let symbols = new Set();\n        for (let s in this.pushdownAlphabet) {\n            let i = this.pushdownAlphabet[s];\n            if (symbols.has(i) || this.inputSyms.has(i)) return false;\n            symbols.add(i);\n        }\n\n        this.pdSyms = symbols;\n        //console.log(this.pdSyms.size());\n        return true;\n    }\n\n    checkStates() {\n        if (this.all.size == 0) return false;\n\n        let states = new Map();\n        for (let i in this.all) {\n            let s = this.all[i];\n            if (states.has(s.name) || this.pdSyms.has(s.name) || this.inputSyms.has(s.name)) return false;\n            states.set(s.name, s);\n        }\n\n        this.states = states;\n        return true;\n    }\n\n    checkInitialState() {\n        if (this.states.has(this.initialState.name)) {\n            //this.initialState = this.states.has(initialState.name);\n            this.initialState.connected = true;\n            return true;\n        }\n        return false;\n    }\n\n    checkInitialStack() {\n        for(let i in initialStack) {\n            let sym = initialStack.substring(i, i+1);\n            if (!this.pdSyms.has(sym)) {\n                //this.initialStack = this.pdSyms.get(initialStack)\n                return false\n            }\n        }\n        \n        return true;\n    }\n\n    checkAccepting() {\n        for (let i in all) {\n            let s = all[i];\n            if (!this.states.has(s)) return false;\n            s.accepting = true;\n            this.accepting.push(s);\n        }\n        return true; \n    \n    }\n\n    checkTransitions() {\n        if (this.transitions.size === 0) return false;\n\n        for (let i in this.transitions) {\n            let t = this.transitions[i];\n            if (t.input != \"eps\" && !this.inputSyms.has(t.input)) return false; // must accept empty\n            if (t.stack0 != \"eps\" && !this.pdSyms.has(t.stack0)) return false;\n            let st = false;\n            let end = false;\n            for (let x in this.all) {\n                let cc = this.all[x];\n                if (st && end) break;\n                if (cc.name === t.source.name) {\n                    st = true;\n                    t.source = cc;\n                }\n                if (cc.name === t.dest.name) {\n                    end = true;\n                    t.dest = cc;\n                }\n                \n            }\n            if (!(st && end)) return false;\n            //if (!this.all.includes(t.source)) return false;\n            //if (!this.all.includes(t.dest)) return false;\n\n            // check new stack:\n            if (t.stack1 != \"eps\") {\n                for (let x in t.stack1) {\n                    let c = t.stack1.substring(x, x+1);\n                    if (!this.pdSyms.has(c)) return false; \n                }\n            }\n            \n\n            //t.source = this.states.get(t.source);\n            //t.dest = this.states.get(t.dest);\n\n            if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input) \n                && this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n                    return false;\n            }\n            // doesn't have the stack symbol yet\n            else if (this.srcToInput.has(t.source) && this.srcToInput.get(t.source).includes(t.input)){\n                let symList = this.srcToInput.get(t.source);\n                symList.push(t.input);\n                this.srcToInput.set(t.source, symList);\n            }\n            // doesnt have the input symbol yet\n            else if (this.srcToStack.has(t.source) && this.srcToStack.get(t.source).includes(t.stack0)) {\n                let symList = this.srcToStack.get(t.source);\n                symList.push(t.stack0);\n                this.srcToStack.set(t.source, symList);\n            }\n            // has the source, but neither the symbol nor the input\n            else if (this.srcToStack.has(t.source) && this.srcToInput.has(t.source)){\n                let inList = this.srcToInput.get(t.source);\n                inList.push(t.input);\n                this.srcToInput.set(t.source, inList);\n                let stackList = this.srcToStack.get(t.source);\n                stackList.push(t.stack0);\n                this.srcToStack.set(t.source, inList);\n            }\n            // state has yet to be recorded as a source\n            else {\n                let inList = new Array(t.input);\n                let stList = new Array(t.stack0);\n                this.srcToInput.set(t.source, inList);\n                this.srcToStack.set(t.source, stList);\n            }\n\n            if (!t.source.conn.includes(t.dest) && t.source.name != t.dest.name) {\n                t.source.conn.push(t.dest);\n                t.source.connected = true; \n                if (t.source.name === this.initialState.name) this.initialState = t.source;\n            }\n        }\n        return true;\n    }\n    \n    makeConnected(start) {\n        for (let i in start.conn) {\n            let s = start.conn[i]; \n            if (!s.connected) {\n                s.connected = true;\n                this.makeConnected(s);\n            }\n        }\n    }\n}\n\n// *TESTS*\n\n/*\n// Non-deterministic\nlet q0 = new State(\"q0\");\nlet q1 = new State(\"q1\");\n\nlet t1 = new Transition(q0, q0, \"a\", \"Z\", \"AZ\"); // (q0, a, Z) -> (q0,A)\nlet t2 = new Transition(q0, q0, \"a\", \"A\", \"AA\"); // (q0, a, A) -> (q0, AA)\nlet t3 = new Transition(q0, q1, \"b\", \"A\", \"\"); // (q0, b, A) -> (q1, eps)\nlet t4 = new Transition(q1, q1, \"b\", \"A\", \"\"); // (q1. b. A) -> (q1, eps)\nlet t5 = new Transition(q1, q1, \"\", \"Z\", \"\"); // (q1, eps, Z) -> (q1, eps)\n\nvar test_states = new Array(q0, q1);\nvar test_inAlphabet = new Array(\"a\", \"b\"); //[\"a\", \"b\"];\nvar test_stAlphabet = new Array(\"A\", \"Z\"); //[\"A\", \"Z\"];\n//console.log(test_stAlphabet.length);\nlet test_accepting = [q1];\nlet test_transitions = [t1, t2, t3, t4, t5];\n\nlet testPDA = new PDAModel(test_states, q0, test_inAlphabet, test_stAlphabet, test_transitions, \"Z\", q1);\n\nconsole.log(testPDA.checkInputString(\"aaabbb\"));\n*/\nlet statebox = \"q0, q1\";\nlet _transitions = \"(q0, a, Z) -> (q0,A); (q0, a, A) -> (q0, AA); (q0, b, A) -> (q1, eps); (q1, b, A) -> (q1, eps); (q1, eps, Z) -> (q1, eps)\";\nlet startstatebox = \"q0\";\nlet startStack = \"Z\";\nlet inputbox = \"a, b\";\nlet stackBox = \"A, Z\";\nlet finalbox = \"q1\";\n\n\nlet _states = parseStates(statebox);\nlet _inAlph = parseInputAlphabet(inputbox);\nlet _pdAlph = parsePushdownAlphabet(stackBox);\nlet _acc = parseStates(finalbox);\nlet _trans = parseTransitions(_transitions);\nlet _initSt = startstatebox;\n\nlet _testPDA1 = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, startStack, _acc);\n\nlet astring1 = \"aaabbb\"; // Z\nlet astring2 = \"aaaabbbb\"; // Z\nlet astring3 = \"abbb\"; // AZAZ\nlet astring4 = \"bbbbb\"; // AAAAA\nlet astring5 = \"bbb\"; // AZAZAZZZZ\n\nlet rstring1 = \"aabbba\"; // A, Z, AAZ\nlet rstring2 = \"\"; // anything: A, Z, AA, AAZZ\nlet rstring3 = \"ab\" // Z\nlet rstring4 = \"a\" // Z, A\nlet rstring5 = \"aaabbb\"; // AA, A\n\nif (_testPDA1.checkInputString(astring1)) {\n    console.log(\"test1: correct output\");\n}\nelse console.log(\"fail test1\");\nif (_testPDA1.checkInputString(astring2)) {\n    console.log(\"test2: correct output\");\n}\nelse console.log(\"fail test2\");\n\nlet _newTestStates = parseStates(\"q0, q1\");\nlet _newTestTransitions = parseTransitions(\"(q0, a, Z) -> (q0,A); (q0, a, A) -> (q0, AA); (q0, b, A) -> (q1, eps); (q1, b, A) -> (q1, eps); (q1, eps, Z) -> (q1, eps)\");\nlet _newTestStartState = \"q0\";\nlet _newTestStartStack = \"Z\";\nlet _newTestInputAlphabet = parseInputAlphabet(\"a, b\");\nlet _newTestPushdownAlphabet = parsePushdownAlphabet(\"A, Z\");\nlet _newTestAccepting = parseStates(\"q1\");\n\nlet _testPDA2_withNewObjects  = new PDAModel(_newTestStates, _newTestStartState, _newTestInputAlphabet, _newTestPushdownAlphabet, _newTestTransitions, _newTestStartStack, _newTestAccepting);\nif (_testPDA2_withNewObjects.checkInputString(astring3)) {\n    console.log(\"new test3: correct output\");\n}\nelse console.log(\"fail new test3\");\n\nlet _testPDA2 = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"AZAZ\", _acc);\nif (_testPDA2.checkInputString(astring3)) {\n    console.log(\"test3: correct output\");\n}\nelse console.log(\"fail test3\");\n\nlet _testPDA3 = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"AAAAA\", _acc);\nif (_testPDA3.checkInputString(astring4)) {\n    console.log(\"test4: correct output\");\n}\nelse console.log(\"fail test4\");\n\nlet _testPDA4 = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"AZAZAZZZZ\", _acc);\nif (_testPDA4.checkInputString(astring5)) {\n    console.log(\"test5: correct output\");\n}\nelse console.log(\"fail test5\");\n\nlet _A_PDA = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"A\", _acc);\nlet _Z_PDA = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"Z\", _acc);\nlet _AAZ_PDA = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"AAZ\", _acc);\nlet _AA_PDA = new PDAModel(_states, _initSt, _inAlph, _pdAlph, _trans, \"A\", _acc);\nif (!_A_PDA.checkInputString(\"aabbba\")) {\n    console.log(\"test6: correct output - rejected\");\n}\nif (!_A_PDA.checkInputString(\"a\")) {\n    console.log(\"test7: correct output - rejected\");\n}\nif (!_Z_PDA.checkInputString(\"aabbba\")) {\n    console.log(\"test8: correct output - rejected\");\n}\nif (!_AAZ_PDA.checkInputString(\"aabbba\")) {\n    console.log(\"test9: correct output - rejected\");\n}\nif (!_Z_PDA.checkInputString(\"ab\")) {\n    console.log(\"test10: correct output - rejected\");\n}\nif (!_Z_PDA.checkInputString(\"a\")) {\n    console.log(\"test11: correct output - rejected\");\n}\nif (!_AA_PDA.checkInputString(\"aaabbb\")) {\n    console.log(\"test12: correct output - rejected\");\n}\nif (!_A_PDA.checkInputString(\"aaabbb\")) {\n    console.log(\"test13: correct output - rejected\");\n}\nif (!_A_PDA.checkInputString(\"\")) {\n    console.log(\"test14: correct output - rejected\");\n}\nif (!_Z_PDA.checkInputString(\"\")) {\n    console.log(\"test15: correct output - rejected\");\n}\nif (!_AA_PDA.checkInputString(\"\")) {\n    console.log(\"test16: correct output - rejected\");\n}\nif (!_AAZ_PDA.checkInputString(\"\")) {\n    console.log(\"test17: correct output - rejected\");\n}\n\n\n\n\n//console.log(t1.input);\n//let transArr = parseTransitions(\"(q0, a, S) -> (q1, S); (q1, e, S) -> (q2, SS)\");\n//console.log(transArr[0].input);\n//console.log(transArr[1].stack1);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}